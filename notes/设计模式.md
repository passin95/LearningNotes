

# 一、设计模式简述

## 1.1 定义

本质上是前人针对某类特定场景的问题所总计出来的代码设计经验。

## 1.2 作用

改善系统的设计，提高代码的复用率、可维护性、可拓展性、可读性。

通俗的讲，随着需求的累加，我们使用正确的代码设计后，可以依旧轻松的去维护和迭代项目代码。

设计模式只是前人对代码经验的单方面总结，不是用来限制我们敲代码的，不能为了用设计模式而写代码，需要根据实际的团队和需求去考量，因为我们所编写的代码最终都是人来阅读和维护的，然后才是顺便给机器运行。

## 1.3 六大原则

设计模式的设计一般需要遵循以下的原则：

- 单一职责原则；
- 开放封闭原则；
- 里氏替换原则；
- 依赖倒置原则；
- 接口隔离原则；
- 最少知道原则（迪米特法则）；

### 1.3.1 单一职责原则

类的职责要单一。

例如：一个网络请求包含了请求重试、报文拼接、缓存、I/O读写等步骤，应当将不同的功能拆成不同的类去实现。若所有功能都写在一个类中，后期便会出现类过于庞大从而难以维护的情况，此外由于功能之间会耦合严重，想进行重构拆分时也难度递增。

该原则不仅仅在设计模式的创建上要遵守，在日常的开发过程中更应该遵守。

### 3.2 里氏替换原则

 子类可以替换掉父类并且可以正常工作，而子类也可以在父类的基础上添加自己新的行为。

```java
public class Demo {

    public static void main(String[] args) {
        runMethod(new Parent());
        runMethod(new SubClass());
    }

    public static class Parent {

        public void method() {
            System.out.println("parent method");
        }

    }

    public static class SubClass extends Parent {

        public void method() {
            // 按里式替换的原则就是：父类可以完成的地方，用子类替代也决定是没有问题的。
            throw new UnsupportedOperationException();
        }

    }

    public static void runMethod(Parent parent) {
        parent.method();
    }

}
```

里式替换原则在大部分情况是需要遵守的，即子类不能删除父类的实现，但规则是死的，有时我们可能由于各种原因，需要违背该原则，因此需要做到灵活使用。

### 1.3.3 依赖倒置原则

“面向接口编程编程，而不是面向实现编程”。由于实现都是易变的，但抽象是稳定的，这样当调用方依赖于抽象时，实现的变化并不会影响到调用方。

依赖导致原则的好处除了可以隐藏实现的变化、易于拓展之外（切换不用实现类），还可以只暴露只想对外提供的 API。因此在设计模式的设计和日常开发中都经常使用到。

### 1.3.4 接口隔离原则

设计接口的时候功能要精简单一。不要让一个单一的接口承担过多的职责，而应把每个职责分离到多个专门的接口中，进行接口分离。

实例开发时往往为了节省时间，可能会将多个功能的方法抽成一个接口，这样不仅会强制实现的人不得不实现本来不该实现的方法，更严重的是会给使用者造成假象，即认为实现类已经实现了所有行为，实际调用方法时却没收获到想要的结果。

### 1.3.5 最少知道原则

一个模块或对象应尽量少的与其他类的实体之间有太多接触，使得系统功能模块相对独立，这样当一个模块修改时，影响的模块就会越少（高内聚、低耦合）。该原则的实现细节主要体现在：

1. 一个功能类应当尽可能的少提供 public 的方法以及不提供 public 的变量。两者是相辅相成的，将类的封装性做的很好，那么其它类的实体就无法依赖当中的细节。
2. 此外我们可以通过只提供接口（实现类不对外公开）的方式只暴露只想对外提供的 API。

### 1.3.6 开放封闭原则

一个实体（类、函数、模块等）应该对扩展开放，对修改关闭。主要体现在：

1. 需求发生改变时都不需要或不能修改原有的代码，而只需要加入一些新的实现。
2. 如果修改一个稳定的方法，可能对旧代码中引入 BUG 或修改了他原本的行为，因此需要通过添加新的方法增强现有类型的行为。

尽量对其它五大原则进行遵守，这样最终设计出来的系统就比较符合开闭原则。

# 二、24 种设计模式

创建型：对类的实例化进行抽象。
结构型：处理类和对象的组合


- 创建型：**单例模式**、简单工厂模式、工厂方法模式、抽象工厂模式、**建造者模式**、原型模式。
- 结构型：代理模式、**适配器模式**、装饰器模式、桥接模式、组合模式、享元模式、外观模式。  
- 行为型：**观察者模式**、模板方法模式、命令模式、状态模式、**职责链模式**、解释器模式、中介者模式、访问者模式、**策略模式**、备忘录模式、迭代器模式。

## 2.1 创造型

### 2.1.1 单例模式

- 设计原则：无。
- 使用场景：希望对象在进程中全局单例。

这里主要说明2种最常用的单例实现方式：

**（1）静态内部类**

需要注意的是该种单例实现方式，不能在类静态实例化的构造方法中去引用一个未进行过类加载的静态变量，否则会抛出 ExceptionInInitializerError。

由于代码随时存在变动，因此若由于任何刚需原因需要在构造函数中引用类变量，则直接使用 **双重校验锁** 作为单例实现方式。

```java
public class Singleton {

    private Singleton() {
    }

    private static class Holder {
        // 由 JVM 中的类加载机制保证单例，只有第一次引用到 Holder 类时才实例化 INSTANCE 类变量。
        private static Singleton INSTANCE = new Singleton();
    }

    public static Singleton getInstance() {
        return Singleton.Holder.INSTANCE;
    }

}
```

**（2）双重校验锁**

```java
public class Singleton {

    private static volatile Singleton sInstance;

    private Singleton() {
    }

    public static Singleton getInstance() {
        if (sInstance == null) {
            // 加 volatile 的作用除了保证变量的可读性外，还禁止 Singleton 变量相关的指令重排序，
            // 因为代码读取到 instance 不为 null 时，instance 引用的对象有可能还没有完成初始化。
            synchronized (Singleton.class) {
                if (sInstance == null) {
                    sInstance = new Singleton();
                    // memory = allocate();　 1：分配对象的内存空间
                    // ctorInstance(memory);　2：初始化对象
                    // instance = memory;　　 3：sInstance 指向刚分配的内存地址
                }
            }
        }
        return sInstance;
    }

}
```

### 2.1.2 简单工厂模式

简单工厂模式又叫静态方法模式（因为工厂类定义了一个静态方法），但不属于GOF（Gang of Four）23种设计模式之一。简单工厂模式我们可以理解为负责生产对象的一个类，称为“工厂类”。

- 设计模式：遵循单一职责、违背开闭原则。
- 使用场景：产品需要拥有统一的产品接口（也可以是一个抽象类，甚至一个普通的父类，但通常来说接口是最稳定的），对调用方来说，可以屏蔽掉具体产品的入参并且不需要关心具体产品的实现，实现了解耦。
- 相关设计模式：
   - 工厂方法模式：这两者的选择主要看工厂是否有进一步抽象化的必要，如果工厂的作用仅仅是用来创建产品，则没必要使用工厂方法模式。

基本实现如下：

<div align="center"> <img src="../pictures//简单工厂模式.webp"/> </div><br>

（1）产品接口，定义具体产品的公共接口:

```java
public interface IProduct {

    public void function();
}
```

（2）两个具体的产品：

```java
public class ProductA implements IProduct {

    public void function() {
        System.out.println("产品 A 方法");
    }

}
```

```java
public class ProductB implements IProduct {

    public void function() {
        System.out.println("产品 B 方法");
    }

}
```

（3）工厂类：通过静态方法传入不同参数创建不同具体产品类的实例。

```java
public class Factory {

    private Factory() {
    }

    @Nullable
    public static IProduct createProduct(String productName) {
        switch (productName){
            case "A":
                return new ProductA();
            case "B":
                return new ProductB();
            default:
                // 可能没有该产品。
                return null;
        }
    }

}
```

（4）Client 调用：

```java
public class Client {

    public static void main(String[] args) {
        IProduct product1 = Factory.createProduct("A");
        product1.function();
        
        IProduct product2 = Factory.createProduct("B");
        product2.function();
    }
}
```

### 2.1.3 工厂方法模式

- 设计模式：遵循单一职责、依赖倒置、开闭原则。
- 使用场景：核心在于关注点更在于工厂，而不是工厂所创造的产品。工厂在切换生产的产品时，对于客户端来说无需改动任何代码，可维护性更好。
- 相关设计模式：
    - 抽象工厂模式：工厂方法模式中，工厂创造的是一个产品，而在抽象工厂模式中，工厂创造的是一个产品族。

基本实现如下：

<div align="center"> <img src="../pictures//工厂方法模式.png"/> </div><br>

（1）抽象工厂类（也可以是接口），定义工厂的公共抽象方法：
 
```java
public abstract class Factory {

    public abstract IProduct createProduct();
}
```

（2）产品接口，定义具体产品的公共接口:

```java
public interface IProduct {

    public void function();
}
```

（3）创建具体产品类：

```java
public class ProductA implements IProduct {

    public void function() {
        System.out.println("产品 A 方法");
    }

}
```

```java
public class ProductB implements IProduct {

    public void function() {
        System.out.println("产品 B 方法");
    }

}
```

（4）创建具体工厂类：

```java
public class FactoryA extends Factory {

    @Override
    public Product createProduct() {
        // 我们可以随时更换该工厂所生产的产品。
        return new ProductA();
    }
}
```

```java
public class FactoryB extends Factory {

    @Override
    public Product createProduct() {
        return new ProductB();
    }
}
```

（5）Client 调用：

```java
public class Client {

    public static void main(String[] args) {
        Factory factory = new FactoryA();
        factory.createProduct().function();
        
        factory = new FactoryB();
        factory.createProduct().function();
    }
}
```

### 2.1.4 抽象工厂模式

- 设计原则：遵循单一职责、依赖倒置、开闭原则。
- 常用场景：在工厂方法模式的基础上，抽象工厂弥补了工厂方法只能创造一个系列的产品，但需要注意的是对于所有工厂来说是否有一致的抽象产品接口。

UML 类图直接以实际的应用场景举例，这样能更好的进行理解，场景取自： Java 1.8 中的 List、ArrayList、LinkedList，因此不再贴具体代码。

<div align="center"> <img src="../pictures//抽象工厂模式.png"/> </div><br>

### 2.1.5 建造者模式

设计原则：遵循单一职责、开闭原则。
常用场景：不同产品的构造过程相同且构造过程复杂。

笔者不是很推崇传统所说的建造者模式，由于限制极大导致使用极少（主要适用于每次实例化传参确定且复杂），因此笔者只简述一下传统的建造者模式，再介绍笔者所常用的建造者模式。

### 2.1.5.1 传统的建造者模式

（1）创建动物模型：

```java
public class Animal {

    private String name;

    private String body;

    private String head;

    private String leftHand;

    private String rightHand;

    private String leftLeg;

    private String rightLeg;

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public String getBody() {
        return body;
    }

    public void setBody(String body) {
        this.body = body;
    }

    public String getHead() {
        return head;
    }

    public void setHead(String head) {
        this.head = head;
    }

    public String getLeftHand() {
        return leftHand;
    }

    public void setLeftHand(String leftHand) {
        this.leftHand = leftHand;
    }

    public String getRightHand() {
        return rightHand;
    }

    public void setRightHand(String rightHand) {
        this.rightHand = rightHand;
    }

    public String getLeftLeg() {
        return leftLeg;
    }

    public void setLeftLeg(String leftLeg) {
        this.leftLeg = leftLeg;
    }

    public String getRightLeg() {
        return rightLeg;
    }

    public void setRightLeg(String rightLeg) {
        this.rightLeg = rightLeg;
    }

}
```

（2）构建构造 Animal 的规则接口：

```java
public interface AnimalBuilder {

    void buildName();

    void buildBody();

    void buildHead();

    void buildLeftHand();

    void buildRightHand();

    void buildLeftLeg();

    void buildRightLeg();

    Animal build();

}
```

（3）创建 Dog 建造者：

```java
public class DogBuilder implements AnimalBuilder {

    private Animal mAnimal = new Animal();

    @Override
    public void buildName() {
        mAnimal.setName("dog");
    }

    @Override
    public void buildBody() {
        mAnimal.setBody("dog body");
    }

    @Override
    public void buildHead() {
        mAnimal.setHead("dog head");
    }

    @Override
    public void buildLeftHand() {
        mAnimal.setLeftHand("dog left hand");
    }

    @Override
    public void buildRightHand() {
        mAnimal.setRightHand("dog right hand");
    }

    @Override
    public void buildLeftLeg() {
        mAnimal.setLeftLeg("dog left leg");
    }

    @Override
    public void buildRightLeg() {
        mAnimal.setRightLeg("dog right leg");
    }

    @Override
    public Animal build() {
        buildName();
        buildBody();
        buildHead();
        buildLeftHand();
        buildRightHand();
        buildLeftLeg();
        buildRightLeg();
        return mAnimal;
    }

}
```

（4）Client 调用：

public class Client {

    public static void main(String[] args) {
        Animal dog = new DogBuilder().build();
    }
}

### 2.5.1.2 笔者常用的建造者模式

在实际开发过程中，极少出现每次实例化传参都是确定的情况，大部分情况都是对部分字段进行赋值，剩余字段都是直接使用默认值，因此笔者更推荐接下来所说的建造者模式，它具有以下几个优点：

1. 链式调用使得实例化传参的对象变得简洁易读。
2. 只需调用需要改变的字段的方法，其它字段使用默认值，最后建造出来的类的构造方法只需要一个。

该种方式的缺点就是多消耗额外的内存实例化了一个 Builder 对象，因此在经常需要实例化的环境下，可以用对象池的思想去复用 Builder 对象。

接下来以 OkHttp 的部分源码详细说明如何运用：

```java
public class OkHttpClient 
  final Dispatcher dispatcher;
  final Proxy proxy;
  final List<Protocol> protocols;
  final List<ConnectionSpec> connectionSpecs;
  final List<Interceptor> interceptors;
  final List<Interceptor> networkInterceptors;
  // 省略部分参数的配置
 public static final class Builder {
    Dispatcher dispatcher;
    Proxy proxy;
    List<Protocol> protocols;
    List<ConnectionSpec> connectionSpecs;
    final List<Interceptor> interceptors = new ArrayList<>();
    final List<Interceptor> networkInterceptors = new ArrayList<>();
    // 省略部分参数的配置

    public Builder() {
      // 可以在 Builder 对象实例化时或调用 build() 方法时对成员变量进行默认赋值。
      dispatcher = new Dispatcher();
      protocols = DEFAULT_PROTOCOLS;
      connectionSpecs = DEFAULT_CONNECTION_SPECS;
    }

    public OkHttpClient build() {
      return new OkHttpClient(this);
    }

    public Builder proxy(Proxy proxy) {
      this.proxy = proxy;
      return this;
    }

    public Builder dispatcher(Dispatcher dispatcher) {
      if (dispatcher == null) throw new IllegalArgumentException("dispatcher == null");
      this.dispatcher = dispatcher;
      return this;
    }

    public Builder connectionSpecs(List<ConnectionSpec> connectionSpecs) {
      this.connectionSpecs = Util.immutableList(connectionSpecs);
      return this;
    }

    public Builder addInterceptor(Interceptor interceptor) {
      interceptors.add(interceptor);
      return this;
    }

    public Builder addNetworkInterceptor(Interceptor interceptor) {
      networkInterceptors.add(interceptor);
      return this;
    }

```

Client 调用：

```java
OkHttpClient.Builder builder = new OkHttpClient.Builder();
builder.addInterceptor(new Interceptor1());
builder.addNetworkInterceptor(new Interceptor2());
OkHttpClient okHttpClient = builder.build();
```

### 2.1.6 原型模式

- 设计原则：无
- 使用场景：通过拷贝已有的原型对象，创建一个新的对象。

实现方式一：Java 中 Object 类中有一个方法 clone()，而 Java 中的任何类只要实现了 Cloneable 标识接口，就可以调用 clone() 来进行对象的拷贝，但需要注意浅拷贝和深拷贝的问题，更详细的解析可到 [Java 基础](./Java%20基础.md#54-clone) 中查看。 

实现方式二：通过序列化再反序列生成一个新的对象，例如 Serializable、Parcelable、Gson 等。

## 2.2 结构型

## 2.2.1 代理模式

代理模式可以分为两种，一种是静态代理，一种是动态代理。

#### 2.2.1.1 静态代理

对于静态代理，代理类一般都要持有一个被代理的对象的引用。主要从使用场景去理解静态代理模式。
   
- 设计原则：部分场景符合单一原则，部分场景符合依赖倒置原则。
- 使用场景：
  1. 通过静态代理对象，在代理对象中执行客户端不需要关心或可复用的代码。
  2. 添加一个 type，对代理方法内容进行单一职责拆分。

第一个使用场景比较容易理解，不再写详细的代码，主要看第二种场景的实现，常用于对复杂的业务代码进行拆分。

（1）定义代理对象和代理方法。

```java
public abstract class BaseItemDelegate {

    protected DemoAdapter mAdapter;

    public BaseItemDelegate(DemoAdapter adapter) {
        mAdapter = adapter;
    }

    abstract public int getLayoutId();

    abstract public void convert(BaseViewHolder helper, ChatMsg item);

    public void onItemChildClick(BaseQuickAdapter adapter, View view, int position) {
    }

}
```

（2）根据不同 type 调用不同代理对象的方法。

```java
public class DemoAdapter extends BaseMultiItemQuickAdapter<Bean> implements OnItemChildClickListener {

    public static final int TYPE_ONE = 0;
    public static final int TYPE_TWO = 1;
    public static final int TYPE_THREE = 2;

    private ArrayMap<Integer, BaseItemDelegate> mItemDelegates = new ArrayMap<>();

    public OnlineChatAdapter(OnlineChatPresenter onlineChatPresenter) {
        super(new ArrayList<ChatMsg>());
        addDelegate(TYPE_ONE, new OneDelegate(this));
        addDelegate(TYPE_TWO, new TwoDelegate(this));
        addDelegate(TYPE_THREE, new ThreeDelegate(this));
        setOnItemChildClickListener(this);
    }

    private void addDelegate(int type, BaseItemDelegate baseItemDelegate) {
        mItemDelegates.put(type, baseItemDelegate);
    }


    @Override
    protected void convert(BaseViewHolder helper, Bean item) {
        // 对 convert() 方法进行代理，传入不同的 type 分发到不同的代理对象，更易维护。
        BaseItemDelegate baseItemDelegate = mItemDelegates.get(helper.getItemViewType());
        if (baseItemDelegate != null) {
            baseItemDelegate.convert(helper, item);
        }
    }

    @Override
    public void onItemChildClick(BaseQuickAdapter adapter, View view, int position) {
        BaseItemDelegate baseItemDelegate = mItemDelegates.get(adapter.getItemViewType(position));
        if (baseItemDelegate != null) {
            baseItemDelegate.onItemChildClick(adapter, view, position);
        }
    }

}
```

#### 2.2.1.2 动态代理

静态代理是我们对方法的实现进行手动替换，而动态代理则更像是一种 AOP 的方式，在调用某个接口类的任意一个方法时，会回调到统一的方法。具体的应用和分析可查看 [Retrofit 源码分析](./Retrofit%20源码分析.md#%E4%B8%89retrofitcreate)。