
<!-- TOC -->

- [一、计算器网络结构](#一计算器网络结构)
    - [1.1 URI 和 URL](#11-uri-和-url)
    - [1.2 TCP/IP](#12-tcpip)
    - [1.3 计算机网络体系结构](#13-计算机网络体系结构)
    - [1.4 从一个 HTTP 请求看计算机网络结构](#14-从一个-http-请求看计算机网络结构)
        - [1.4.1 域名解析](#141-域名解析)
        - [1.4.2 应用层](#142-应用层)
        - [1.4.3 传输层](#143-传输层)
            - [1.4.3.1 TCP](#1431-tcp)
            - [1.4.3.2 UDP](#1432-udp)
        - [1.4.4 网络层](#144-网络层)
        - [1.4.5 数据链路层](#145-数据链路层)
            - [1.4.5.1 MAC 头部](#1451-mac-头部)
            - [1.4.5.2 网卡](#1452-网卡)
            - [1.4.5.3 交换机](#1453-交换机)
            - [1.4.5.4 路由器](#1454-路由器)
        - [1.4.6 物理层](#146-物理层)
- [二、HTTP](#二http)
    - [2.1 请求报文和响应报文](#21-请求报文和响应报文)
    - [2.2 请求方法](#22-请求方法)
    - [2.3 HTTP 状态码](#23-http-状态码)
        - [2.3.1 1XX 信息](#231-1xx-信息)
        - [2.3.2 2XX 成功](#232-2xx-成功)
        - [2.3.3 3XX 重定向](#233-3xx-重定向)
        - [2.3.4 4XX 客户端错误](#234-4xx-客户端错误)
        - [2.3.5 5XX 服务器错误](#235-5xx-服务器错误)
    - [2.4 HTTP 首部（请求头）](#24-http-首部请求头)
        - [2.4.1 通用首部字段](#241-通用首部字段)
        - [2.4.2 请求首部字段](#242-请求首部字段)
        - [2.4.3 响应首部字段](#243-响应首部字段)
        - [2.4.4 实体首部字段](#244-实体首部字段)
    - [2.5 Content-Type](#25-content-type)
- [三、HTTP 协议实际应用](#三http-协议实际应用)
    - [3.1 Cookie](#31-cookie)
        - [3.1.1 用途](#311-用途)
        - [3.1.2 创建过程](#312-创建过程)
        - [3.1.3 分类](#313-分类)
        - [3.1.4 JavaScript 获取 Cookie](#314-javascript-获取-cookie)
        - [3.1.5 Secure 和 HttpOnly](#315-secure-和-httponly)
        - [3.1.6 Session](#316-session)
        - [3.1.7 浏览器禁用 Cookie](#317-浏览器禁用-cookie)
        - [3.1.8 Cookie 与 Session 选择](#318-cookie-与-session-选择)
    - [3.2 缓存](#32-缓存)
        - [3.2.1 作用](#321-作用)
        - [3.2.2 实现方法](#322-实现方法)
        - [3.2.3 Cache-Control](#323-cache-control)
        - [3.2.4 缓存验证](#324-缓存验证)
    - [3.3 Authorization](#33-authorization)
        - [3.3.1 Basic](#331-basic)
        - [3.3.2 Bearer](#332-bearer)
            - [3.3.2.1 OAuth2 授权流程](#3321-oauth2-授权流程)
            - [3.3.2.2 OAuth2 微信授权登陆流程](#3322-oauth2-微信授权登陆流程)
            - [3.3.2.3 在自家 App 中使用 Bearer token](#3323-在自家-app-中使用-bearer-token)
            - [3.3.2.4 为什么引入 Authorization code](#3324-为什么引入-authorization-code)
            - [3.3.2.5 Refresh token](#3325-refresh-token)
    - [3.4 连接管理](#34-连接管理)
        - [3.4.1 短连接与长连接](#341-短连接与长连接)
        - [3.4.2 管道网络传输](#342-管道网络传输)
    - [3.5 内容协商](#35-内容协商)
        - [3.5.1 类型](#351-类型)
        - [3.5.2 Vary](#352-vary)
    - [3.6 内容编码](#36-内容编码)
    - [3.7 范围请求](#37-范围请求)
        - [3.7.1 Range](#371-range)
        - [3.7.2 Accept-Ranges](#372-accept-ranges)
        - [3.7.3 响应状态码](#373-响应状态码)
    - [3.8 分块传输编码](#38-分块传输编码)
    - [3.9 多部分对象集合](#39-多部分对象集合)
    - [3.10 WebSocket](#310-websocket)
        - [3.10.1 连接过程](#3101-连接过程)
        - [3.10.2 数据帧格式](#3102-数据帧格式)
- [四、HTTPS](#四https)
    - [4.1 加密](#41-加密)
        - [4.1.1 对称密钥加密](#411-对称密钥加密)
        - [4.1.2 非对称密钥加密](#412-非对称密钥加密)
    - [4.2 证书（认证）](#42-证书认证)
        - [4.2.1 证书包含的信息](#421-证书包含的信息)
        - [4.2.2 证书的验证过程](#422-证书的验证过程)
    - [4.3 完整性保护](#43-完整性保护)
    - [4.4 HTTPS 的缺点](#44-https-的缺点)
    - [4.5 HTTPS 连接建立过程](#45-https-连接建立过程)
- [五、GET 和 POST 的区别](#五get-和-post-的区别)
    - [5.1 作用](#51-作用)
    - [5.2 参数](#52-参数)
    - [5.3 安全](#53-安全)
    - [5.4 幂等性](#54-幂等性)
    - [5.5 可缓存](#55-可缓存)
- [六、HTTP/1.1、HTTP/2、HTTP/3](#六http11http2http3)
    - [6.1 HTTP/1.1](#61-http11)
    - [6.2 HTTP/2](#62-http2)
        - [6.2.1 HTTP/1.1 的性能瓶颈](#621-http11-的性能瓶颈)
        - [6.2.2 头部压缩](#622-头部压缩)
        - [6.2.3 二进制帧](#623-二进制帧)
        - [6.2.4 多路复用](#624-多路复用)
        - [6.2.5 服务器主动推送资源](#625-服务器主动推送资源)
    - [6.3 HTTP/3](#63-http3)
        - [6.3.1 HTTP/2 的性能瓶颈](#631-http2-的性能瓶颈)
        - [6.3.2 QUIC 协议](#632-quic-协议)
            - [6.3.2.1 无队头阻塞](#6321-无队头阻塞)
            - [6.3.2.2 更快的连接建立](#6322-更快的连接建立)
            - [6.3.2.3 连接迁移](#6323-连接迁移)
        - [6.3.3 HTTP/3 协议结构](#633-http3-协议结构)
- [七、Socket](#七socket)
- [八、TCP](#八tcp)
    - [8.1 三次握手](#81-三次握手)
    - [8.2 四次挥手](#82-四次挥手)
    - [8.3 TCP 的原理和优化](#83-tcp-的原理和优化)
        - [8.3.1 重传机制](#831-重传机制)
            - [8.3.1.1 超时重传](#8311-超时重传)
            - [8.3.1.2 快速重传](#8312-快速重传)
            - [8.3.1.3 SACK 方法](#8313-sack-方法)
            - [8.3.1.4 Duplicate SACK](#8314-duplicate-sack)
        - [8.3.2 滑动窗口](#832-滑动窗口)
        - [8.3.3 流量控制](#833-流量控制)
            - [8.3.3.1 窗口关闭](#8331-窗口关闭)
            - [8.3.3.2 糊涂窗口综合症](#8332-糊涂窗口综合症)
        - [8.3.4 拥塞控制](#834-拥塞控制)
            - [8.3.4.1 慢启动](#8341-慢启动)
            - [8.3.4.2 拥塞避免](#8342-拥塞避免)
            - [8.3.4.3 拥塞发生](#8343-拥塞发生)
            - [8.3.4.4 快速恢复](#8344-快速恢复)
- [参考资料](#参考资料)

<!-- /TOC -->

# 一、计算器网络结构

## 1.1 URI 和 URL

- URI（Uniform Resource Identifier，统一资源标识符）；
- URL（Uniform Resource Locator，统一资源定位符）；
- URN（Uniform Resource Name，统一资源名称），例如 urn:isbn:0-486-27557-4。

URI 包含 URL 和 URN，目前 WEB 只有 URL 比较流行，所以见到的基本都是 URL。

<div align="center"> <img src="../pictures//URI%20和%20URL%20的关系.webp" /> </div>

URI 的结构如下，它们都是等价的，只不过划分的区域不同：
```
[scheme:]scheme-specific-part[#fragment]
[scheme:][//authority][path][?query][#fragment]
[scheme:][//host:port][path][?query][#fragment]
```

以下用一个 URI 字符串来横向对比各部分结构的区别。

```
http://www.demo.com:8080/path/path1?key=value&key1=value1&key2=value2#demofragment
```

- scheme：URI 的模式，例如 http、file、content 等，Deme 中为 http；
- scheme-specific-part：//www.demo.com:8080/path/path1?key=value&key1=value1&key2=value2；
- authority：www.demo.com:8080；
- host：URI 的主机域名或 IP 地址，Demo 中为 www.demo.com；
- port：端口号，Demo 中为 8080；
- path：路径信息，Demo 中为 /yourpath/fileName.htm；
- query：键对值，Deme 中为 key=value&key1=value1&key2=value2；
- fragment：用来标识次级资源，Demo 中为 demofragment。

## 1.2 TCP/IP

<div align="center"> <img src="../pictures//TCPIP.png" width="400"/> </div>

TCP/IP 是互联网相关的各类协议族的总称。

## 1.3 计算机网络体系结构

计算机网络体系结构如下图所示：

<div align="center"> <img src="../pictures//计算机网络体系结构.webp"/> </div>

- OSI 网络模型：为了使得多种设备能通过网络相互通信，以及为了解决各种不同设备在网络互联中的兼容性问题，国际标标准化组织制定了开放式系统互联通信参考模型（Open System Interconnection Reference Model）；
- TCP/IP 网络模型：由于 OSI 模型实在太复杂，提出的也只是概念理论上的分层，并没有提供具体的实现方案。而 TCP/IP 网络模型其实是 OSI 模型的实现，也是我们比较常用和实用的网络模型；
- 五层协议网络模型：TCP/IP 网络模型的抽象，主要是为了方便更清楚的阐述计算机网络。

分层管理的概念，不管是软件开发还是现实生活中都经常使用的一种手段，由于网络通讯存在种种不稳定的因素，通过单一职责化隔离每一层的作用，这样使上层结构不需要关心下层的来源，只需要对接相关的接口，这样不仅更利于未来的维护，也能从架构层面提高稳定性。

## 1.4 从一个 HTTP 请求看计算机网络结构

一个 HTTP 请求一般经过以下几个过程：

<div align="center"> <img src="../pictures//TCP%20连接过程.webp"/> </div>

### 1.4.1 域名解析

浏览器解析 URL 并生成 HTTP 报文后，需要委托操作系统将消息发送给 Web 服务器，而有一种服务器专门保存了 Web 服务器域名与 IP 的对应关系，它就是 DNS 服务器。

域名服务器的层级关系类似一个树状结构：

<div align="center"> <img src="../pictures//DNS结构.webp" width="500"/> </div>

域名解析的工作流程：

1. 客户端发出一个域名解析的请求：问本地 DNS 服务器（一般是客户端 IPv4 填写的 DNS） www.server.com 的 IP 地址是多少；
2. 本地 DNS 服务器收到请求后，先查询缓存中是否能找到对应域名的 IP 地址，如果找到则直接返回；如果没有，本地 DNS 会去问它的根域名服务器，根域名服务器是最高层次的，它不直接用于域名解析；
3. 根域名服务器收到来自本地 DNS 的请求后，发现后缀是 .com，回复道：“www.server.com 这个域名归 .com 区域管理”，我给你 .com 顶级域名服务器地址给你，你去问它吧。”；
4. 本地 DNS 收到顶级域名服务器的地址后，发起请求“你能告诉我 www.server.com 的 IP 地址吗？”；
5. 顶级域名服务器说：“我给你负责 www.server.com 区域的权威 DNS 服务器的地址，你去问它应该能问到”；
6. 本地 DNS 于是转向问权威 DNS 服务器，为啥叫权威呢？就是我的域名我做主；
7. 权威 DNS 服务器查询后将对应的 IP 地址告诉本地 DNS；
8. 本地 DNS 再将 IP 地址返回客户端，客户端和目标建立连接。

域名解析通信过程，主要使用的是 UDP 传输，原因是：一是没有 TCP 三次握手的过程，从而响应时间较短，性能更好；二是 DNS 的查询响应报文比较小，满足 UDP 报文长度的限制。

### 1.4.2 应用层

应用层协议定义的是不同设备应用进程间的通信规则，不用去关心数据是如何传输的。

对于不同的网络应用需要不同的应用层协议，例如域名系统 DNS，支持万维网应用的 HTTP 协议，支持电子邮件的 SMTP 协议等等。数据单元称为报文。

### 1.4.3 传输层

传输层主要提供数据的传输策略，例如如何在多变的网络条件下保证数据的可靠传输。

由于应用层协议很多，定义通用的运输层协议就可以支持不断增多的应用层协议。运输层主要使用两种协议：「传输控制协议 TCP」和「用户数据报协议 UDP」。

#### 1.4.3.1 TCP

TCP 是「面向连接的」、「可靠的」、「基于字节流」的传输层通信协议。

- 面向连接：一定是「一对一」才能连接，不能像「UDP 协议」可以一个主机同时向多个主机发送消息；
- 可靠的：无论的网络链路中出现了怎样的链路变化，TCP 都会尽可能保证报文能够到达接收端。并且消息是「有序的」，当「前一个」消息没有收到的时候，即使它先收到了后面的字节已经收到，那么也不能扔给应用层去处理，同时对「重复」的报文会自动丢弃；
- 字节流：消息是「没有边界」的，无论消息有多大都可以进行传输（本质上是分段传输）。

通信双方在进行通信之前，需要通过三次握手建立连接，确认双方都具有数据收发的能力。

TCP 提供了确认应答、重传机制、滑动窗口、流量控制、拥塞机制等机制来保证数据有序及可靠性。

它的基本思路是对收到的数据进行分割，并在各个分块上打上标记序号及端口号后转发给网络层，这样的好处在于即使中途有一个分块丢失或损坏了，只需要重传这一个分块。

TCP 协议的结构如下图所示：

<div align="center"> <img src="../pictures//TCP报文头部.webp" width="500"/> </div>

- 源端口号和目的端口号：数据的来源端口号和目的端口号；
- 序号：解决包乱序的问题。用来拼接收到的报文段；
- 确认序列：解决不丢包的问题。用于确认发出去的报文对方是否有收到，如果没有收到就应该重新发送，直到送达；
- 状态位：例如「SYN」是发起一个连接，「ACK」是回复，「RST」是重新连接，「FIN」是结束连接等。TCP 是面向连接的，因而双方要维护连接的状态，这些带状态位的包的发送，会引起双方的状态变更；
- 窗口大小：TCP 要做「流量控制」，通信双方各声明一个窗口（缓存大小），标识自己当前能够处理数据的能力；
- 数据：例如使用的是 HTTP 协议，则按照 HTTP 协议拼接 HTTP 头部 + HTTP 报文。

#### 1.4.3.2 UDP

UDP 是一个「无连接」、「不保证可靠交付」、「支持一对多」、「基于报文」的协议。

- 无连接：发送数据前，双方无需建立连接，数据发送完毕后，也无需断开连接（没有连接和断开），这样一来，减少了连接和断开连接的开销（无需像 TCP 连接时需要三次握手，断开连接时需要四次挥手）；
- 不保证可靠交付：它会尽最大努力提供数据传输服务（即不保证可靠交付），即可能会丢包和乱序；
- 支持一对多：UDP 支持一对一、一对多、多对多的交互通信，适用于对高速传输和实时性有较高的通信或广播通信，例如实时游戏、视频通话等；
- 基于报文的：UDP 报文中的数据部分就是完整的一个消息，也就是说每个 UDP 报文就是一个消息的边界。

UDP 协议比较简单，头部只有 8 个字节，结构如下图所示：

<div align="center"> <img src="../pictures//UDP协议.webp" width="500"/> </div>

- 源端口号和目的端口号：数据的来源端口号和目的端口号；
- 包长度：保存了 UDP 首部的长度跟数据的长度之和；
- 校验和：用于校验 UDP 在传输过程中是否出错，从而提供可靠的头部和数据。

> 为什么 UDP 头部没有「首部长度」字段，而 TCP 头部有「首部长度」字段呢？

原因是 TCP 有可变长的「选项」字段，而 UDP 头部长度则是不会变化的，无需多一个字段去记录 UDP 的首部长度。

> 为什么 UDP 头部有「包长度」字段，而 TCP 头部则没有「包长度」字段呢？

因为 TCP 的负载数据长度是可以计算的：

TCP 数据的长度 = IP 总长度 - IP 首部长度 - TCP 首部长度。

其中 IP 总长度 和 IP 首部长度，在 IP 首部格式是已知的。TCP 首部长度，则是在 TCP 首部格式已知的，所以就可以求得 TCP 数据的长度。

### 1.4.4 网络层

网络层负责网络地址将源节点发出的数据包传送到目的节点。该层控制数据链路层与传输层之间的信息转发（涉及到寻址）、建立、维持和终止网络的连接。该层一般是 IP 协议。

IP 协议的报文结构如下图所示：

<div align="center"> <img src="../pictures//IP协议.webp" width="500"/> </div>

- 协议：所使用的传输层协议，例如 TCP 协议；
- 源 IP 地址和目标 IP 地址：数据来源和目标的 IP 地址。

物理链路并不能传输任意大小的数据包，网络包的 **MTU（最大传输单元）** 都是有限的，如 FDDI 数据链路 MTU 是 4352 字节、以太网的 MTU 是 1500 字节等。

经过分片之后的 IP 数据报在被重组的时候，只能由目标主机进行，路由器是不会进行重组的。

因此在分片传输中，一旦某个分片丢失，则会造成整个 IP 数据报作废，极大的影响了传输效率，所以 TCP 引入了 **MSS（最大报文段长度）**，通过也就是在 TCP 层进行分片从而提高传输效率。

而对于 UDP，我们应该尽量不要发送一个大于 **MTU** 的数据报文以提高传输效率。

### 1.4.5 数据链路层

数据链路层的作用主要是负责 MAC 寻址、网络包的封帧、差错检测以及通过网卡传输网络帧等。

#### 1.4.5.1 MAC 头部

MAC 头部是专门在以太网中使用的头部，由于在真正的网络数据传输过程中，会经过很多的链路（在不同的网络中传输），因此 MAC 包头里包含了 **发送方 MAC 地址** 和 **接收方 MAC 地址**，用于 **两点之间的传输**。

MAC 协议包括了以下三个信息：

- 发送方的 MAC 地址：从发送端的网卡 ROM 中取出来写入到 MAC 头部；
- 接收方的 MAC 地址：需要「ARP 协议」帮我们找到路由器的 MAC 地址。ARP 协议会在以太网中以「广播」的形式询问所有设备某 IP 地址所对应的 MAC 地址是多少；
- 协议类型：一般为 IP 协议（0800）或 ARP 协议（0806）。

至此，网络包的报文如下图：

<div align="center"> <img src="../pictures//网络包报文.webp" width="600"/> </div>

#### 1.4.5.2 网卡

物理层的线路由传输介质与通信设备组成，比特流在传输介质上传输时肯定会存在误差的。这样就引入了数据链路层在物理层之上，采用差错检测、差错控制和流量控制等方法，向网络层提供高质量的数据传输服务。

数据链路层必须具备一系列相应的功能，主要有：

1. 如何将数据组合成数据块，在数据链路层中称这种数据块为帧，帧是数据链路层的传送单位；
2. 如何控制帧在物理信道上的传输，包括如何处理传输差错；
3. 如何调节发送速率以使与接收方相匹配；以及在两个网络实体之间提供数据链路通路的建立、维持和释放的管理。

负责执行这一操作的是「网卡」，要控制网卡还需要靠「网卡驱动程序」。

网卡驱动从 IP 模块获取到包之后，会将其 **复制** 到网卡内的缓存区中，接着会 **在其开头加上报头和起始帧分界符，在末尾加上用于检测错误的帧校验序列**。

<div align="center"> <img src="../pictures//网卡在网络包中的负责的部分.webp"/> </div>

- 起始帧分界符：用来表示包起始位置的标记；
- 帧校验序列（FCS）：用来检查包传输过程是否有损坏。

最后通过网卡将「数字信息转换为电信号」，通过网线发送出去，也就是说，这才是真正的数据发送过程。

#### 1.4.5.3 交换机

交换机的设计作用是将网络包原样转发到目的地。交换机工作在 MAC 层，也称为「二层网络设备」。

接下来先看一下交换机的工作流程：

（1）首先，电信号到达网线接口，交换机里的模块进行接收，并将电信号转换为数字信号；

（2）然后通过包末尾的 **FCS** 校验是否出错，如果没问题则放到缓冲区。这部分操作基本和计算机的网卡相同，但交换机的工作方式和网卡不同。
  
计算机的网卡本身具有 MAC 地址，并通过核对收到的包的接收方 MAC 地址判断是不是发给自己的，如果不是发给自己的则丢弃；相对地，由于交换机的端口 **不具有 MAC 地址**，因此交换机的端口不核对接收方 MAC 地址，而是直接接收所有的包并存放到缓冲区中。

（3）将包存入缓冲区后，会先进行地址学习：** 将「发送方的 MAC 地址」和「收到包的交换机端口」 写入 MAC 地址表中 **。

（4）接下来需要查询一下这个包的 **「接收方 MAC 地址」是否在 MAC 地址表中**。

若存在则将包发送到相应的端口；若不存在，说明具有该地址的设备还没有向交换机发送过包（或长时间未工作被删），此时会将包转发到除了源端口之外的所有端口上，最终 **只有正确的接收者才会接收包，而其他设备则会忽略这个包**。

此外，如果接收方 MAC 地址是一个广播地址，那么交换机会将包发送到除源端口之外的所有端口。以下两个属于广播地址：

- MAC 地址中的 FF:FF:FF:FF:FF:FF；
- IP 地址中的 255.255.255.255。

#### 1.4.5.4 路由器

网络包经过交换机之后，现在到达了路由器，并在此被转发到下一个路由器或目标设备。

这一步转发的工作原理和交换机类似，也是通过查表判断包转发的目标。不过在具体的操作过程上，路由器和交换机是有区别的：

- 路由器是基于「IP」设计的，俗称三层网络设备，路由器的各个端口都具有 MAC 地址和 IP 地址；
- 交换机是基于「以太网」设计的，俗称二层网络设备，交换机的端口不具有 MAC 地址。

接下来看一下路由器的工作流程：

1. 首先，电信号到达网线接口，路由器中的模块会进行接收，并将电信号转换为数字信号；
2. 然后通过包末尾的 **FCS** 校验是否出错，如果没问题则检查 MAC 头部中的接收方 MAC 地址，看看是不是发给自己的包，如果是就放到接收缓冲区中，否则就忽略这个包；
3. 完成包接收操作之后，路由器就会 **去掉包中的 MAC 头部**（因此此刻包的 MAC 头部的作用就是将包送达到指定路由器或设备），然后根据 IP 头部中的内容进行包的转发操作；

<div align="center"> <img src="../pictures//路由表结构.webp"/> </div>

4. 将包的接收方 IP 地址与每个条目的子网掩码做 & 运算，若得到的结果等于路由表中的 **目标地址栏**，即作为候选转发目标；若找不到匹配路由时，就会选择默认路由（子网掩码为 0.0.0.0 的条目）转发目标；
5. 所选条目的「网关」如果是一个 IP 地址，表示这个 IP 地址就是我们要转发到的目标地址，**也说明还未抵达终点**；如果网关为空，则该条目的目标地址就是 IP 包头里的目标地址了，**说明已抵达终点**；
6. 知道对方的 IP 地址之后，接下来需要通过「ARP 协议」根据 IP 地址查询 MAC 地址，并将查询的结果作为接收方 MAC 地址写入包中；
7. 接下来会将其转换成电信号通过端口发送出去，发送出去的网络包会通过 **交换机** 到达下一个路由器。经过层层转发之后，网络包就到达了最终的目的地。

### 1.4.6 物理层

物理层主要是为数据链路层提供二进制传输的服务，即确保原始的数据可在各种物理媒体上传输。

# 二、HTTP

- 超文本传输协议，现用于作为网络请求「传输」文字、图片、音频、视频等「超文本」数据的「约定和规范」；
- HTTP 位于 TCP/IP 协议族中的最顶层———应用层。

## 2.1 请求报文和响应报文

**（1）请求报文**

<div align="center"> <img src="../pictures//HTTP%20请求报文.png"/> </div><br>

**（2）响应报文**

<div align="center"> <img src="../pictures//HTTP%20响应报文.png"/> </div><br>

## 2.2 请求方法

**（1）GET**

- 用于获取资源；
- 不会修改服务器数据；
- 不发送 Body。

**（2）HEAD**

- 用于获取报文首部，即返回的响应没有 Body。

**（3）POST**

- 用于增加或修改资源；
- 传输内容写在 Body 中。

**（4）PUT**

- 向指定资源位置上传其最新内容；
- 传输内容写在 Body 中。

**（4）DELETE**

- 删除指定资源位置的资源；
- 请求报文没有请求体。

## 2.3 HTTP 状态码

服务器返回的 **响应报文** 中第一行为状态行，包含了状态码以及原因短语，用来告知客户端请求的结果。

| 状态码 | 类别 | 原因短语 |
| :---: | :---: | :---: |
| 1XX | Informational（信息性状态码） | 接收的请求正在处理 |
| 2XX | Success（成功状态码） | 请求正常处理完毕 |
| 3XX | Redirection（重定向状态码） | 需要进行附加操作以完成请求 |
| 4XX | Client Error（客户端错误状态码） | 服务器无法处理请求 |
| 5XX | Server Error（服务器错误状态码） | 服务器处理请求出错 |

### 2.3.1 1XX 信息

-  **100 Continue** ：表明到目前为止都很正常，客户端可以继续发送请求 (例如传输文件过大，需要分段传输，服务器返回 100 表示已经接受到客户端的需要，让客户端继续传输) 或者忽略这个响应。

### 2.3.2 2XX 成功

-  **200 OK**：请求成功；
-  **204 No Content** ：请求已经成功处理，但是返回的响应报文不包含实体的主体部分。一般在只需要从客户端往服务器发送信息，而不需要返回数据时使用；
-  **206 Partial Content** ：表示客户端进行了范围请求。响应报文包含由 Content-Range 指定范围的实体内容。

### 2.3.3 3XX 重定向

-  **301 Moved Permanently** ：永久性重定向；

-  **302 Found** ：临时性重定向；

-  **303 See Other** ：和 302 有着相同的功能，但是 303 明确要求客户端应该采用 GET 方法获取资源；

注：虽然 HTTP 协议规定 301、302 状态下重定向时不允许把 POST 方法改成 GET 方法，但是大多数浏览器都会在 301、302 和 303 状态下的重定向把 POST 方法改成 GET 方法。

-  **304 Not Modified** ：如果请求报文首部包含一些条件，例如：If-Match，If-Modified-Since，If-None-Match，If-Range，If-Unmodified-Since，如果如果网页自请求者上次请求后再也没有更改过，则服务器会返回 304 状态码；

-  **307 Temporary Redirect** ：临时重定向，与 302 的含义类似，但是 307 要求浏览器不会把重定向请求的 POST 方法改成 GET 方法。

### 2.3.4 4XX 客户端错误

-  **400 Bad Request** ：请求报文中存在语法错误；

-  **401 Unauthorized** ：该状态码表示发送的请求需要有认证信息（BASIC 认证、DIGEST 认证）。如果之前已进行过一次请求，则表示用户认证失败；

-  **403 Forbidden** ：请求被拒绝，服务器端没有必要给出拒绝的详细理由；

-  **404 Not Found** ：请求地址不存在；

-  **407 Proxy Authentication Required** ：需要代理授权，和 401 类似，但指定请求者应当授权使用代理。

### 2.3.5 5XX 服务器错误

-  **500 Internal Server Error** ：服务器正在执行请求时发生错误；

-  **503 Service Unavailable** ：服务器暂时处于超负载或正在进行停机维护，现在无法处理请求。

## 2.4 HTTP 首部（请求头）

有 4 种类型的首部字段：通用首部字段、请求首部字段、响应首部字段和实体首部字段。

各种首部字段及其含义如下（不需要全记，仅供查阅）：

### 2.4.1 通用首部字段

| 首部字段名 | 说明 |
| :--: | :--: |
| Cache-Control | 控制缓存的行为 |
| Connection | 控制不再转发给代理的首部字段、管理持久连接|
| Date | 创建报文的日期时间 |
| Pragma | 报文指令 |
| Trailer | 报文末端的首部一览 |
| Transfer-Encoding | 指定报文主体的传输编码方式 |
| Upgrade | 升级为其他协议 |
| Via | 代理服务器的相关信息 |
| Warning | 错误通知 |

### 2.4.2 请求首部字段

| 首部字段名 | 说明 |
| :--: | :--: |
| Accept | 用户代理可处理的媒体类型 |
| Accept-Charset | 优先的字符集 |
| Accept-Encoding | 优先的内容编码 |
| Accept-Language | 优先的语言（自然语言） |
| Authorization | Web 认证信息 |
| Expect | 期待服务器的特定行为 |
| From | 用户的电子邮箱地址 |
| Host | 请求资源所在服务器 |
| If-Match | 比较实体标记（ETag） |
| If-Modified-Since | 比较资源的更新时间 |
| If-None-Match | 比较实体标记（与 If-Match 相反） |
| If-Range | 资源未更新时发送实体 Byte 的范围请求 |
| If-Unmodified-Since | 比较资源的更新时间（与 If-Modified-Since 相反） |
| Max-Forwards | 最大传输逐跳数 |
| Proxy-Authorization | 代理服务器要求客户端的认证信息 |
| Range | 实体的字节范围请求 |
| Referer | 对请求中 URI 的原始获取方 |
| TE | 传输编码的优先级 |
| User-Agent | 用户代理 |

### 2.4.3 响应首部字段

| 首部字段名 | 说明 |
| :--: | :--: |
| Accept-Ranges | 是否接受字节范围请求 |
| Age | 推算资源创建经过时间 |
| ETag | 资源的匹配信息 |
| Location | 令客户端重定向至指定 URI |
| Proxy-Authenticate | 代理服务器对客户端的认证信息 |
| Retry-After | 对再次发起请求的时机要求 |
| Server | HTTP 服务器的安装信息 |
| Vary | 代理服务器缓存的管理信息 |
| WWW-Authenticate | 服务器对客户端的认证信息 |

### 2.4.4 实体首部字段

| 首部字段名 | 说明 |
| :--: | :--: |
| Allow | 资源可支持的 HTTP 方法 |
| Content-Encoding | 实体主体适用的编码方式 |
| Content-Language | 实体主体的自然语言 |
| Content-Length | 实体主体的大小 |
| Content-Location | 替代对应资源的 URI |
| Content-MD5 | 实体主体的报文摘要 |
| Content-Range | 实体主体的位置范围 |
| Content-Type | 实体主体的媒体类型 |
| Expires | 实体主体过期的日期时间 |
| Last-Modified | 资源的最后修改日期时间 |

## 2.5 Content-Type

**（1）text/html**

Body 中返回 html 文本。

**（2）x-www-form-urlencoded**

纯文本表单的提交方式。

**（3）multitype/form-data**

含二进制文件时的提交方式。

**（4）application/json，image/jpeg,……**

单项（专项）内容提交，例如 application/json 可直接以 Body 形式传输相应 bean 类。

# 三、HTTP 协议实际应用

## 3.1 Cookie

HTTP 协议是无状态的，主要是为了让 HTTP 协议尽可能简单。为了让它能够处理大量事务，在 HTTP/1.1 中引入 Cookie 来保存状态信息。

Cookie 是服务器发送到用户浏览器并保存在本地的一小块数据，浏览器向同一服务器再次发起请求时 Cookie 会被携带上，用于告知服务端两个请求是否来自同一浏览器。由于之后每次请求都会需要携带 Cookie 数据，因此会带来额外的性能开销（尤其是在移动环境下）。

Cookie 曾一度用于客户端数据的存储，因为当时并没有其它合适的存储办法而作为唯一的存储手段，但现在随着现代浏览器开始支持各种各样的存储方式，Cookie 渐渐被淘汰，但 Cookie 在其它用途上面仍有用武之地。

### 3.1.1 用途

- 会话状态管理（如用户登录状态、购物车、游戏分数或其它需要记录的信息）；
- 个性化设置（如用户自定义设置、主题等）；
- 浏览器行为跟踪（如跟踪分析用户行为等）。

### 3.1.2 创建过程

服务器发送的响应报文包含 Set-Cookie 首部字段，客户端得到响应报文后把 Cookie 内容保存到浏览器（客户端）中。

```html
HTTP/1.1 200 OK
Content-type: text/html
Set-Cookie: yummy_cookie=choco
Set-Cookie: tasty_cookie=strawberry
```

客户端之后对同一个服务器发送请求时，从浏览器中读出 Cookie 信息通过添加 Cookie 请求首部字段发送给服务器。

```html
GET /sample_page.html HTTP/1.1
Host: www.example.org
Cookie: yummy_cookie=choco; tasty_cookie=strawberry
```

### 3.1.3 分类

- 会话期 Cookie：浏览器关闭之后它会被自动删除，也就是说它仅在会话期内有效。
- 持久性 Cookie：指定一个特定的过期时间（Expires）或有效期（max-age）。

```html
Set-Cookie: id=a3fWa; Expires=Wed, 21 Oct 2015 07:28:00 GMT;
```

### 3.1.4 JavaScript 获取 Cookie

通过 `Document.cookie` 属性可创建新的 Cookie，也可通过该属性访问非 HttpOnly 标记的 Cookie。

```html
document.cookie = "yummy_cookie=choco";
document.cookie = "tasty_cookie=strawberry";
console.log(document.cookie);
```

### 3.1.5 Secure 和 HttpOnly

标记为 Secure 的 Cookie 只应通过被 HTTPS 请求发送给服务端。但即便设置了 Secure 标记，敏感信息也不应该通过 Cookie 传输，因为 Cookie 有其固有的不安全性，Secure 标记也无法提供绝对的安全保障。

标记为 HttpOnly 的 Cookie 不能被 JavaScript 脚本调用。因为跨站脚本攻击 (XSS) 常常使用 JavaScript 的 `Document.cookie` API 窃取用户的 Cookie 信息，因此使用 HttpOnly 标记可以在一定程度上避免 XSS 攻击。

```html
Set-Cookie: id=a3fWa; Expires=Wed, 21 Oct 2015 07:28:00 GMT; Secure; HttpOnly
```

### 3.1.6 Session

除了可以将用户信息通过 Cookie 存储在用户浏览器中，也可以利用 Session 存储在服务器端，存储在服务器端的信息也会更加安全。

Session 可以存储在服务器上的文件、数据库或者内存中。也可以将 Session 存储在内存型数据库中，比如 Redis。

使用 Session 维护用户登录的过程如下：

- 用户进行登录时，用户提交包含用户名和密码的表单，放入 HTTP 请求报文中；
- 服务器验证该用户名和密码；
- 如果正确则把用户信息存储到 Redis 中，它在 Redis 中的 ID 称为 Session ID；
- 服务器返回的响应报文的 Set-Cookie 首部字段包含了这个 Session ID，客户端收到响应报文之后将该 Cookie 值存入浏览器中；
- 客户端之后对同一个服务器进行请求时会包含该 Cookie 值，服务器收到之后提取出 Session ID，从 Redis 中取出用户信息，继续之后的业务操作。

应该注意 Session ID 的安全性问题，不能让它被恶意攻击者轻易获取。因此 Session ID 的生成规则应当是不规律的，且还需要经常重新生成 Session ID。在对安全性要求极高的场景下，例如转账等操作，除了使用 Session 管理用户状态之外，还需要对用户进行重新验证，比如重新输入密码，或者使用短信验证码等方式。

### 3.1.7 浏览器禁用 Cookie

此时无法使用 Cookie 来保存用户信息，只能使用 Session。除此之外，不能再将 Session ID 存放到 Cookie 中，而是使用 URL 重写技术，将 Session ID 作为 URL 的参数进行传递。

### 3.1.8 Cookie 与 Session 选择

- Cookie 只能存储 ASCII 码字符串，而 Session 则可以存取任何类型的数据，因此在考虑数据复杂性时首选 Session；
- Cookie 存储在浏览器中，容易被恶意查看。如果非要将一些隐私数据存在 Cookie 中，可以将 Cookie 值进行加密，然后在服务器进行解密；
- 对于大型网站，如果用户所有的信息都存储在 Session 中，那么开销是非常大的，因此不建议将所有的用户信息都存储到 Session 中。

## 3.2 缓存

### 3.2.1 作用

- 缓解服务器压力；
- 降低客户端获取资源的延迟。

### 3.2.2 实现方法

- 让代理服务器进行缓存；
- 让客户端浏览器进行缓存。

### 3.2.3 Cache-Control

HTTP/1.1 通过 Cache-Control 首部字段来控制缓存。

**（1）禁止进行缓存** 

no-store 指令规定不能对请求或响应的任何数据进行缓存。

```html
Cache-Control: no-store
```

**（2）强制确认缓存** 

no-cache 指令规定缓存服务器需要先向源服务器验证缓存资源的有效性，只有当缓存资源有效才将能使用该缓存对客户端的请求进行响应。

```html
Cache-Control: no-cache
```

**（3）私有缓存和公共缓存** 

private 指令规定了将资源作为私有缓存，只能被单独用户所使用，一般存储在用户浏览器中。

```html
Cache-Control: private
```

public 指令规定了将资源作为公共缓存，可以被多个用户所使用，一般存储在代理服务器中。

```html
Cache-Control: public
```

**（四）缓存过期机制** 

max-age 指令出现在请求报文中，并且缓存资源的缓存时间小于该指令指定的时间，那么就能接受该缓存。

max-age 指令出现在响应报文中，表示缓存资源在缓存服务器中保存的时间。

```html
Cache-Control: max-age=31536000
```

Expires 首部字段也可以用于告知缓存服务器该资源什么时候会过期。在 HTTP/1.1 中，会优先处理 Cache-Control : max-age 指令；而在 HTTP/1.0 中，Cache-Control : max-age 指令会被忽略掉。

```html
Expires: Wed, 04 Jul 2012 08:26:05 GMT
```

### 3.2.4 缓存验证

ETag 它是资源的唯一标识。URL 不能唯一表示资源，例如 `http://www.google.com/` 有中文和英文两个资源，只有 ETag 才能对这两个资源进行唯一标识。

```html
ETag: "82e22293907ce725faf67773957acd12"
```

可以将缓存资源的 ETag 值放入 If-None-Match 首部，服务器收到该请求后，判断缓存资源的 ETag 值和资源的最新 ETag 值是否一致，如果一致则表示缓存资源有效，返回 304 Not Modified。

```html
If-None-Match: "82e22293907ce725faf67773957acd12"
```

Last-Modified 首部字段也可以用于缓存验证，它包含在源服务器发送的响应报文中，指示源服务器对资源的最后修改时间。但是它是一种弱校验器，因为只能精确到一秒，所以它通常作为 ETag 的备用方案。如果响应首部字段里含有这个信息，客户端可以在后续的请求中带上 If-Modified-Since 来验证缓存。服务器只在所请求的资源在给定的日期时间之后对内容进行过修改的情况下才会将资源返回，状态码为 200 OK。如果请求的资源从那时起未经修改，那么返回一个不带有消息主体的 304 Not Modified 响应。

```html
Last-Modified: Wed, 21 Oct 2015 07:28:00 GMT
```

```html
If-Modified-Since: Wed, 21 Oct 2015 07:28:00 GMT
```

## 3.3 Authorization

第三方授权分为两种主流方式： Basic 和 Bearer 。

### 3.3.1 Basic

- 首部字段格式：Authorization: Basic Base64 (username:password)
> 例如：用户名为 passin ，密码为 123456 ，连起来则是 passin:123456 ,再对该字符串进行 Base64 编码，结果为 cGFzc2luOjEyMzQ1Ng==。即，最终添加进请求头的内容是：

```html
Authorization: Basic cGFzc2luOjEyMzQ1Ng==
```

### 3.3.2 Bearer

- 首部字段格式：Authorization: Bearer <bearer token>
- bearer token 的获取方式：通过 OAuth2 的授权流程。

#### 3.3.2.1 OAuth2 授权流程

> 1. 第三方网站向授权方网站申请第三方授权合作，目的是拿到 client id 和 client secret。
> 2. 用户在使用第三方网站时，点击授权（登陆）按钮后，跳转授权方网站，并传入 client id（第三方网站提供）作为用户的身份标识。
> 3. 授权方网站根据 client id ，将第三方网站的信息和第三方网站需要的用户权限展示给用户，并询问用户是否同意授权。
> 4. 用户同意授权后，授权方网站将页面跳转回第三方网站，并传入 Authorization code 作为用户认可的凭证。
> 5. 第三方网站将 Authorization code 发送回自己的服务器。
> 6. 服务器将 Authorization code 和自己的 client secret 一并发送给授权方的服务器，授权方服务器验证通过后，返回 access token。
> 7. 第三方网站（客户端）就可以使用 access token 作为用户授权的令牌，向授权方发送请求来获取用户信息或操作用户账号。

#### 3.3.2.2 OAuth2 微信授权登陆流程

> 1. 第三方 App 向微信开放平台申请第三方授权登陆，拿到 client id 和 client secret。
> 2. 用户在使用第三方 App 时，点击微信登陆按钮后，将通过微信 SDK 跳转至微信，并传入自己的 client id 作为用户的身份标识。
> 3. 微信通过与服务器交互，拿到第三方 App 信息，并限制在微信界面中，将第三方 App 的信息和第三方网站需要的用户权限展示给用户，并询问用户是否同意授权。
> 4. 用户点击 『同意授权』后，微信 App 和 服务区交互将同意授权的信息提交，然后跳转回第三方 App，并传回 Authorization code 作为用户认可的凭证。
> 5. 第三方 App 调用自家服务器的『微信登录』 Api，并传入 Authorization code，并等待服务器的响应。
> 6. 服务器将拿到的 Authorization code 和自己的 client secret 通过调用授权方接口发送给授权方的服务器，微信服务器验证通过后，返回 access token。
> 7. 第三方服务器拿到 access token 作为用户授权的令牌，向微信服务器请求接口来获取用户信息，微信验证同意后，返回用户信息。
> 8. 服务器拿到微信提供的用户信息后，例如该信息在自己的服务器为用户创建一个账号，并将自身服务器的用户 Id 和微信账号的用户 Id 做关联。
> 9. 用户创建完成后，向客户端返回成功的响应以及创建的用户信息。
> 10. 客户端收到响应，利用返回的用户数据进行操作，最终用户登录成功。

#### 3.3.2.3 在自家 App 中使用 Bearer token

简化掉获取 Authorization code 的过程，登录接口请求成功后，直接返回 access token。

#### 3.3.2.4 为什么引入 Authorization code

为了安全，OAuth 并不强制使用 Https，因此需要尽量保证当通信时被窃听时，依旧具有足够的安全性。
- 服务器之间的通信以及服务器自身的数据一般是较为安全的。
- 需要 Authorization code 以及第三方服务器自身才有的 client secret 才能拿到 access token。

#### 3.3.2.5 Refresh token

```
{
        "token_type" : "Bearer",
        "access_token" : "xxxxx",
        "refresh_token" : "xxxxx",
        "expires_time" : "xxxxx",
}
```

用法：accress token 只在一定时间内有效，在它失效后，可调用 refresh_token 接口，并传入 refresh_token 中的参数获取新的 access token。

目的：为了更安全。当 accress token 失窃时，窃取人只有较短时间的去利用它模拟请求接口，而 refresh_token 的值则永远存放于第三方服务器中，不容易失窃。

## 3.4 连接管理

### 3.4.1 短连接与长连接

当浏览器访问一个包含多张图片的 HTML 页面时，除了请求访问 HTML 页面资源，还会请求图片资源，如果每进行一次 HTTP 通信就要断开一次 TCP 连接，连接建立和断开的开销会很大。长连接只需要建立一次 TCP 连接就能进行多次 HTTP 通信。

从 HTTP/1.1 开始默认是长连接的，如果要断开连接，需要由客户端或者服务器端提出断开，添加头部 Connection : close；而在 HTTP/1.1 之前默认是短连接的，如果需要长连接，则添加头部 Connection : Keep-Alive。

长连接的实现方式：每间隔一定时间,使用 TCP 连接发送很短且无意义的消息,让服务器网关不将自己定义为“空闲连接”,从而防止网关关闭连接。

### 3.4.2 管道网络传输

默认情况下，HTTP 请求是按顺序发出的，下一个请求只有在当前请求收到响应之后才会被发出。由于会受到网络延迟和带宽的限制，在下一个请求被发送到服务器之前，可能需要等待很长时间。

管道机制则是允许浏览器同时发出多个请求，而不用等待响应返回，这样可以避免连接延迟，但是服务器还是按照「请求顺序」回应，如果前面的回应特别慢，后面就会有许多请求排队等着。这称为「队头堵塞」。

## 3.5 内容协商

通过内容协商返回最合适的内容，例如根据浏览器的默认语言选择返回中文界面还是英文界面。

### 3.5.1 类型

**（一）服务端驱动型内容协商** 

客户端请求报文设置特定的 HTTP 首部字段，例如 Accept、Accept-Charset、Accept-Encoding、Accept-Language、Content-Languag，服务器根据这些字段返回特定的资源。

它存在以下问题：

- 服务器很难知道客户端浏览器的全部信息；
- 客户端提供的信息相当冗长（HTTP/2 协议的首部压缩机制缓解了这个问题），并且存在隐私风险（HTTP 指纹识别技术）；
- 给定的资源需要返回不同的展现形式，共享缓存的效率会降低，而服务器端的实现会越来越复杂。

**（二）代理驱动型协商** 

服务器返回 300 Multiple Choices 或者 406 Not Acceptable，客户端从中选出最合适的那个资源。

### 3.5.2 Vary

```html
Vary: Accept-Language
```

在使用内容协商的情况下，只有当缓存服务器中的缓存满足内容协商条件时，才能使用该缓存，否则应该向源服务器请求该资源。

例如，一个客户端发送了一个包含 Accept-Language 首部字段的请求之后，源服务器返回的响应包含 `Vary: Accept-Language` 内容，缓存服务器对这个响应进行缓存之后，在客户端下一次访问同一个 URL 资源，并且 Accept-Language 与缓存中的对应的值相同时才会返回该缓存。

## 3.6 内容编码

内容编码将实体主体进行压缩，从而减少传输的数据量。常用的内容编码有：gzip、compress、deflate、identity。

浏览器发送 Accept-Encoding 首部，其中包含有它所支持的压缩算法，以及各自的优先级，服务器则从中选择一种，使用该算法对响应的消息主体进行压缩，并且发送 Content-Encoding 首部来告知浏览器它选择了哪一种算法。由于该内容协商过程是基于编码类型来选择资源的展现形式的，在响应中，Vary 首部中至少要包含 Content-Encoding，这样的话，缓存服务器就可以对资源的不同展现形式进行缓存。

## 3.7 范围请求

如果网络出现中断，服务器只发送了一部分数据，范围请求可以使得客户端只请求服务器未发送的那部分数据，从而避免服务器重新发送所有数据。

### 3.7.1 Range

在请求报文中添加 Range 首部字段指定请求的范围。

```html
GET /z4d4kWk.jpg HTTP/1.1
Host: i.imgur.com
Range: bytes=0-1023
```

请求成功的话服务器返回的响应包含 206 Partial Content 状态码。

```html
HTTP/1.1 206 Partial Content
Content-Range: bytes 0-1023/146515
Content-Length: 1024
...
(binary content)
```

### 3.7.2 Accept-Ranges

响应首部字段 Accept-Ranges 用于告知客户端是否能处理范围请求，可以处理使用 bytes，否则使用 none。

```html
Accept-Ranges: bytes
```

### 3.7.3 响应状态码

- 在请求成功的情况下，服务器会返回 206 Partial Content 状态码。
- 在请求的范围越界的情况下，服务器会返回 416 Requested Range Not Satisfiable 状态码。
- 在不支持范围请求的情况下，服务器会返回 200 OK 状态码。

## 3.8 分块传输编码

分块传输编码（Chunked Transfer EnCoding） 可以把一个 Http 连接的数据分割成多块，边传输边接收。

作用：

- 服务器向客户端发送数据：让浏览器逐步显示页面，尽早给出响应，减少用户等待。
- 客户端向服务器发送数据：请求体的 Body 长度无法确定，Content-Length 不能使用。

Body 格式：

```
<length1>
<data1>
<length2>
<data2>
……
0

(最后传输 0 表示内容结束)
```

## 3.9 多部分对象集合

一份报文主体内可含有多种类型的实体同时发送，每个部分之间用 boundary 字段定义的分隔符进行分隔，每个部分都可以有首部字段。

例如，上传多个表单时可以使用如下方式：

```html
Content-Type: multipart/form-data; boundary=AaB03x

--AaB03x
Content-Disposition: form-data; name="submit-name"

--AaB03x
Content-Disposition: form-data; name="files"; filename="file1.txt"
Content-Type: text/plain

... contents of file1.txt ...
--AaB03x--
```

## 3.10 WebSocket

WebSocket 是基于 TCP 实现的全双工应用层协议。特殊在于，WebSocket 在建立连接时，需要借用 HTTP 的 101 switch protocol 来达到协议转换。在建立连接后，再往后发送数据就是通过 TCP 协议了，也就是说 WebSocket 只是使用 Http 协议来完成握手操作。

### 3.10.1 连接过程

**（1）请求报文**

```
Host: server.example.com
Upgrade: websocket
Connection: Upgrade
Sec-WebSocket-Key: dGhlIHNhbXBsZSBub25jZQ==
Origin: http://example.com
Sec-WebSocket-Protocol: chat, superchat
Sec-WebSocket-Version: 13
```

简单描述一下各个请求头的含义：

- Upgrade：HTTP1.1 开始表示要升级（转换）到某个协议（如果服务器支持的话）。

- Connection：内容为 Upgrade 表示要进行升级协议。

- Sec-WebSocket-Key：用来发送给服务器过滤非预期的请求 (比如手动填写 header 中的一些信息，但本身不想升级到 WebSocket。这时候，由于 Sec-WebSocket-Key 和一些相关项被禁止手动设置，所以可以过滤掉出现非预期的情况)。

- Origin：防止跨站攻击，浏览器一般会使用这个来标识原始域。

- Sec-WebSocket-Protocol：客户端支持的子协议列表。

- Sec-WebSocket-Version：客户端支持的 WebSocket 协议的版本。

**（2）响应报文**

```
HTTP/1.1 101 Switching Protocols
Upgrade: websocket
Connection: Upgrade
Sec-WebSocket-Accept: s3pPLMBiTxaQ9kYGzzhZRbK+xOo=
Sec-WebSocket-Protocol: chat
```

### 3.10.2 数据帧格式

遵循 RFC 规范实现的 WebSocket，协议自带包长，不会有产生粘包/拆包问题，因此，可以认为 WebSocket 的功能之一就是专门处理 TCP 粘包问题，并在 TCP 的基础上，封装了一些帧实现，方便开发者使用。

```
  0                   1                   2                   3
  0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
 +-+-+-+-+-------+-+-------------+-------------------------------+
 |F|R|R|R| opcode|M| Payload len |    Extended payload length    |
 |I|S|S|S|  (4)  |A|     (7)     |             (16/64)           |
 |N|V|V|V|       |S|             |   (if payload len==126/127)   |
 | |1|2|3|       |K|             |                               |
 +-+-+-+-+-------+-+-------------+ - - - - - - - - - - - - - - - +
 |     Extended payload length continued, if payload len == 127  |
 + - - - - - - - - - - - - - - - +-------------------------------+
 |                               |Masking-key, if MASK set to 1  |
 +-------------------------------+-------------------------------+
 | Masking-key (continued)       |          Payload Data         |
 +-------------------------------- - - - - - - - - - - - - - - - +
 :                     Payload Data continued ...                :
 + - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - +
 |                     Payload Data continued ...                |
 +---------------------------------------------------------------+
```

- FIN：（finish）1 bit。

  如果是 1，表示这是消息的最后一个分片（fragment）；如果是 0，表示不是最后一个分片。
  
- RSV1, RSV2, RSV3：各占 1 bit。

  若不采用 WebSocket 扩展这里必须为 0。当客户端、服务端协商采用 WebSocket 扩展时，这三个标志位可以非 0，且值的含义由扩展进行定义。如果出现非零的值，且没有采用 WebSocket 扩展，则连接出错。

- Opcode：4 bit。

  操作码。Opcode 的值决定了应该如何解析后续的数据载荷（data payload），可以理解为 HTTP 的响应体。如果收到一个未知的操作码，接收端点应该断开连接（fail the connection）。可选的操作代码如下：

```
%x0：表示一个延续帧。当 Opcode 为 0 时，表示本次数据传输采用了数据分片，当前收到的数据帧为其中一个数据分片；
%x1：表示这是一个文本帧（frame）；
%x2：表示这是一个二进制帧（frame）；
%x3-7：保留的操作代码，用于后续定义的非控制帧，（一般协议中都会预留出一些码用于扩展）；
%x8：表示连接断开/关闭；
%x9：表示这是一个 ping 操作；
%xA：表示这是一个 pong 操作；
%xB-F：保留的操作代码，用于后续定义的控制帧（一般协议中都会预留出一些码用于扩展）。
```
- Mask：1 bit。

  表示是否要对数据载荷进行掩码操作。从客户端向服务端发送数据时，需要对数据进行掩码操作，Mask 需要为 1，masking-key（掩码键）字段存在值；从服务端向客户端发送数据时，不需要对数据进行掩码操作，Mask 需要为 0。如果服务端接收到的数据没有进行过掩码操作，服务端需要断开连接。

- Payload length：数据载荷的长度，单位是 bit。

  代表了用多少 bit 来表示数据的长度。
  
  当数据的长度在 0-125 之间时，Payload length 为 7；当数据的长度在 126-2^16-1 时，Payload length 为 7+16；当数据的长度在 2^16-1~2^64-1 时，Payload length 为 7+64。

  该算法的实现原理：7 bit 能表示的最大数值为 127，但只用它来表示 125 内（包含）的数据长度，若为 126 则表示需要额外 2 个字节的长度，若为 127 则需要额外 8 个字节的长度。这种定义负载长度方式是一种网络协议中常用的方法，可以实现灵活的扩展数据长度。

- Masking-key：0 或 4 字节（32 位）

  所有从客户端传送到服务端的数据帧，数据载荷都进行了掩码操作，Mask 为 1，且携带了 4 字节的 Masking-key。如果 Mask 为 0，则没有 Masking-key。

- Payload data：(载荷数据 x+y 字节)

  载荷数据：包括了扩展数据、应用数据。其中，扩展数据 x 字节，应用数据 y 字节。载荷数据的长度，不包括 mask key 的长度。

- Extension data（扩展数据 x 字节）：

  如果没有协商使用扩展的话，扩展数据数据为 0 字节。所有的扩展都必须声明扩展数据的长度，或者可以如何计算出扩展数据的长度。此外，扩展如何使用必须在握手阶段就协商好。如果扩展数据存在，那么载荷数据长度必须将扩展数据的长度包含在内。

- Application data（应用数据 y 字节）：

  在扩展数据之后（如果存在扩展数据），应用数据占据了数据帧剩余的位置。即应用数据的长度等于载荷数据长度减去扩展数据长度。

# 四、HTTPS

HTTP 有以下安全性问题：

- 使用明文进行通信，内容可能会被窃听；
- 不验证通信方的身份，通信方的身份有可能遭遇伪装；
- 无法证明报文的完整性，报文有可能遭篡改。

HTTPS 并不是新协议，而是让 HTTP 先和 SSL（Secure Sockets Layer）通信，再由 SSL 和 TCP 通信。也就是说 HTTPS 使用了隧道进行通信。

通过使用 SSL，HTTPS 具有了加密（防窃听）、认证（防伪装）和完整性保护（防篡改）的特性。

HTTP 的默认端口号是 80，HTTPS 的默认端口号是 443。

## 4.1 加密

加密的目的，是不希望第三者看到当前两个通讯用户的通讯内容。

### 4.1.1 对称密钥加密

对称密钥加密（Symmetric-Key Encryption），加密和解密使用同一密钥。

- 优点：运算速度快；
- 缺点：无法安全地将密钥传输给通信方。

### 4.1.2 非对称密钥加密

非对称密钥加密，又称公开密钥加密（Public-Key Encryption），加密和解密使用不同的密钥，公钥都可给予，并且私钥和公钥是互相可解的。

以下用 A（客户端）和 B（服务器）描述非对称密钥加密的应用。

1. B 将公钥发送给 A；
2. A 用 B 给他的公钥加密这段消息，然后传给 B；
3. B 收到消息后使用私有密钥解密（只有接收方有私钥才能解密，从而达到保密的目的）；
4. 若 B 想向 A 回复消息，则 B 用自己的私钥加密信息，发送给 A；
5. A 收到消息后，用公钥解密信息。

- 优点：可以更安全地将公开密钥传输给通信发送方。
- 缺点：运算速度慢。

非对称密钥加密除了用来加密，还可以用来进行签名。此处以 B 给 A 回信为例说明这个过程：

1. B 对信息使用 hash 算法，生成信件摘要；
2. B 再使用其私有密钥进行加密，就生成了数字签名(signature)；
3. B 将这个签名附在要回复的信息中（例如请求头），一起发给 A；
4. A 使用公钥对数字签名进行解密，并对信息使用同样的 hash 算法，将得到 hash 值与这个签名对比是否一致来判断信息是否被篡改。

不怀好意的人也可以修改信息内容的同时也修改 hash 值，从而让它们可以相匹配，为了防止这种情况，hash 值一般都会加密后(也就是数字签名)再和信息一起发送。

## 4.2 证书（认证）

由于客户端无法确定给它公钥的就是真正的服务器，此时则需要通过使用 **证书** 来对通信方进行认证。

「数字证书认证机构（CA，Certificate Authority）」是客户端与服务器双方都可信赖的第三方机构。

CA 用自己的私钥对用户的身份信息(包含用户的公钥)进行数字签名，该签名和用户的身份信息一起就形成了证书。

### 4.2.1 证书包含的信息

- 签发机构的公钥：用于数字签名解密；
- 证书有效期。证书过了有效期限，证书就会作废；
- 证书的所有者（一般是某个人或者某个公司名称、机构的名称、公司网站的网址等）；
- 证书签名算法：证书签名所使用的加密算法。签发机构的公钥，根据这个算法对数字签名进行解密，得到摘要（hash 值）；
- 指纹算法：某种 hash 算法；
- 证书签名：用于保证证书的完整性，确保证书没有被修改过。其原理就是在发布证书时，发布者根据指纹算法计算证书信息得到指纹（hash 值）再使用私钥加密得到数字签名，并和证书放在一起。使用者在打开证书时，使用公钥对证书签名解密得到指纹，并使用指纹算法计算证书信息得到新的指纹，再进行对比是否一致，若一致就说明证书没有被修改过；
- 签发机构的签发机构的......(上面包含的信息)：由于签发机构可以通过另外一个更高级别的签发机构对该证书机构的公钥颁发一个证书（一般是不超过 3 级），这样形成了一个公钥证书的嵌套循环。

### 4.2.2 证书的验证过程 

- 对比证书吊销列表，检查 SSL 证书是否被证书颁发机构吊销；
- 检查 SSL 证书是否过期；
- 检查部署此 SSL 证书的网站的域名是否与证书中的域名一致；
- 检查 SSL 证书是否是由 **系统受信任的根证书颁发机构** 颁发；
- 利用签发机构的公钥对证书签名进行验证，如果验证过后所得的信息和证书签名一致，则验证通过。依次逐级对签发机构进行验证，直至本地所信任的根签发机构验证通过。

## 4.3 完整性保护

SSL 提供报文摘要功能来进行完整性保护。

HTTP 也提供了 MD5 报文摘要功能，但不是安全的。例如报文内容被篡改之后，同时重新计算 MD5 的值，通信接收方无法意识到发生了篡改。

HTTPS 的报文摘要功能之所以安全，是因为它结合了加密和认证这两个操作。因为加密之后的报文，遭到篡改之后，也很难重新计算为一致的报文摘要，因为无法轻易获取明文。

## 4.4 HTTPS 的缺点

- 因为需要进行加密解密等过程，因此速度会更慢；
- 需要支付证书授权的费用。

## 4.5 HTTPS 连接建立过程

1. 客户端向服务器发送一条消息 **Client Hello**，Client Hello 包含的内容：客户端所能接受的（多个）SSL/TLS 版本、加密算法（对称加密算法和非对称加密算法）、hash 算法、一个客户端随机数、Server Name（表明是客户端与服务器下哪一个具体的子服务器建立链接）；
2. 服务器接收到 Client Hello 后，将客户端随机数保存下来，并从中确定将要使用的 SSL/TLS 版本、加密算法、hash 算法；
3. 服务器向客户端发送一条消息 **Server Hello**，消息中包含一个随机数以及确定使用的 SSL/TLS 版本、加密算法、hash 算法，客户端也将此随机数保存下来，自此客户端和服务器皆拥有一个客户端随机数和一个服务器随机数（用于计算 Pre-master Secret）；
4. 服务器再向客户端发送「服务端证书」，CA 的公钥已事先内置到客户端系统中，客户端使用它进行证书验证。验证通过后，从证书中取出「服务器非对称加密的公钥」；
5. 客户端通过自己的信息算出一个 Pre-master Secret，并使用「服务器非对称加密的公钥」进行加密，再发送给服务器（两端皆存）；
6. 两端利用 Pre-master Secret、客户端随机数、服务器随机数使用一个固定算法算出一个名为 Master Secret 的数据。再解析 Master Secret 得到真正进行通讯时用的客户端加密密钥、服务端加密密钥（对称加密密钥）；
7. 客户端向服务器发送一条消息：**Change Cipher Spec**，“我”将使用加密通信了；
8. 客户端再向服务器发送一条消息： **Finished**。该消息的内容为：将所有的握手信息和客户端加密密钥进行 [HMAC](https://baike.baidu.com/item/hmac/7307543?fr=aladdin) 运算的结果；
9. 服务器向客户端发送一条消息：**Change Cipher Spec**，“我”将使用加密通信了；
10. 服务器再向客户端发送一条消息： **Finished**。该消息的内容为：服务器也进行同样的 HMAC 运算后与客户端对比，一致则认为客户端是合法的。若合法，服务器将所有的握手信息以及客户端的 HMAC 的结果和服务器加密密钥进行 HMAC 运算后发给客户端；
11. 客户端接收到服务端的 **Finished** 后，同样以相同算法进行对比验证以确定服务端以及密钥是否是合法（正确）的。若验证通过，则开始用「对称加密密钥」进行 HTTP 请求。

# 五、GET 和 POST 的区别

## 5.1 作用

GET 用于获取资源，而 POST 用于传输实体主体。

## 5.2 参数

GET 和 POST 的请求都能使用额外的参数，但是 GET 的参数是拼接在 URL 中，而 POST 的参数存储在请求体中。

```
GET /test/demo_form.asp?name1=value1&name2=value2 HTTP/1.1
```

```
POST /test/demo_form.asp HTTP/1.1
Host: w3schools.com
name1=value1&name2=value2
```

不能因为 POST 参数存储在实体主体中就认为它的安全性更高，因为照样可以通过一些抓包工具（Fiddler）查看。

因为 URL 只支持 ASCII 码，因此 GET 的参数中如果存在中文等字符就需要先进行编码，例如`中文`会转换为`%E4%B8%AD%E6%96%87`，而空格会转换为`%20`。POST 支持标准字符集。

## 5.3 安全

这里所说的安全是相对的，主要指数据不会被篡改。

安全的 HTTP 方法不会改变服务器状态，也就是说它只是可读的。因此 GET 方法是安全的，而 POST 是不安全的，因为 POST 的目的是传送实体主体内容，这个内容可能是用户上传的表单数据，上传成功之后，服务器可能把这个数据存储到数据库中，因此状态也就发生了改变。

安全的方法除了 GET 之外还有：HEAD、OPTIONS。

不安全的方法除了 POST 之外还有 PUT、DELETE。

## 5.4 幂等性

幂等的 HTTP 方法，同样的请求被执行一次与连续执行多次的效果是一样的，服务器的状态也是一样的。换句话说就是，幂等方法不应该具有副作用（统计用途除外）。在正确实现的条件下，GET，HEAD，PUT 和 DELETE 等方法都是幂等的，而 POST 方法不是。所有的安全方法也都是幂等的。

GET /pageX HTTP/1.1 是幂等的。连续调用多次，客户端接收到的结果都是一样的：

```
GET /pageX HTTP/1.1
GET /pageX HTTP/1.1
GET /pageX HTTP/1.1
GET /pageX HTTP/1.1
```

POST /add_row HTTP/1.1 不是幂等的。如果调用多次，就会增加多行记录：

```
POST /add_row HTTP/1.1   -> Adds a 1nd row
POST /add_row HTTP/1.1   -> Adds a 2nd row
POST /add_row HTTP/1.1   -> Adds a 3rd row
```

DELETE /idX/delete HTTP/1.1 是幂等的，即便不同的请求接收到的状态码不一样：

```
DELETE /idX/delete HTTP/1.1   -> Returns 200 if idX exists
DELETE /idX/delete HTTP/1.1   -> Returns 404 as it just got deleted
DELETE /idX/delete HTTP/1.1   -> Returns 404
```

## 5.5 可缓存

如果要对响应进行缓存，需要满足以下条件：

- 请求报文的 HTTP 方法本身是可缓存的，包括 GET 和 HEAD，但是 PUT 和 DELETE 不可缓存，POST 在多数情况下不可缓存的。
- 响应报文的状态码是可缓存的，包括：200, 203, 204, 206, 300, 301, 404, 405, 410, 414, and 501。
- 响应报文的 Cache-Control 首部字段没有指定则不缓存。

# 六、HTTP/1.1、HTTP/2、HTTP/3

<div align="center"> <img src="../pictures//HTTP协议的区别.webp"/> </div>

## 6.1 HTTP/1.1

HTTP/1.1 相比 HTTP/1.0 性能上的改进：

- 使用 TCP 长连接的方式改善了 HTTP/1.0 短连接造成的性能开销。

- 支持「管道网络传输」，只要第一个请求发出去了，不必等其回来，就可以发第二个请求出去，可以减少整体的响应时间。

## 6.2 HTTP/2

### 6.2.1 HTTP/1.1 的性能瓶颈

- 请求 / 响应头部（Header）未经压缩就发送，只能压缩 Body 的部分；

- 发送冗长的首部。每次互相发送相同的首部造成的浪费较多；

- 服务器是按请求的顺序响应的，如果服务器响应慢，会导致客户端一直请求不到数据，也就是「HTTP 队头阻塞」；

- 没有请求优先级控制；

- 请求只能从客户端开始，服务器只能被动响应。

HTTP/2 相比 HTTP/1.1 性能上的改进：

### 6.2.2 头部压缩

HTTP/2 不再使用常用的 gzip 压缩方式来压缩头部，而是开发了 HPACK 算法，HPACK 算法主要包含三个组成部分：「静态字典」、「动态字典」、「Huffman 编码（压缩算法）」。

HPACK 算法本质上是在客户端和服务器同时维护一张头信息表，用长度较小的索引号替换重复的字符串继续发送，再用 Huffman 编码压缩数据，**可达到 50%~90% 的高压缩率**。

**（1）静态表编码**

「静态表编码」是将在 HTTP 请求中高频出现的头部筛选出来，建立成一张静态表。例如请求方法、状态码等，部分 key-value 是定死的，也制定了协议支持 value 是可变的。


| Index | Header Name | Header Value |
| :---- | :---------- | :----------- |
| 1     | :authority  |              |
| 2     | :method     | GET          |
| 3     | :method     | POST         |
| 4     | :path       | /            |
| 5     | :path       | /index.html  |
| 6     | :scheme     | http         |
| 7     | :scheme     | https        |
| 8     | :status     | 200          |
| ……    | ……          | ……           |

HPACK 算法的的头部格式如下图所示：

<div align="center"> <img src="../pictures//HTTP2静态表编码头部格式.webp" width="600"/> </div>

- 第一个字节：根据 RFC7541 规范，如果头部字段属于静态表范围，并且 Value 是变化，那么它的 HTTP/2 头部前 2 位固定为 **01**，后六位表示 Index。
- 第二个字节：首个比特位表示 Value 是否经过 Huffman 编码（1 为代表是经过 Huffman 编码），剩余的 7 位表示 Value 的长度。

**（2）动态表编码**

静态表只包含了 61 种高频出现在头部的字符串，不在静态表范围内的头部字符串就要自行构建动态表，它的 Index 从 62 起步。

由于需要客户端和服务端同时维护一样的动态表，因此动态表编码 **必须同一个连接上，且重复传输完全相同（key-value 都相同）的 HTTP 头部**。

动态表编码本质上是一个空间换时间的优化方案，随着在同一 HTTP/2 连接上发送的报文越来越多，客户端和服务器双方的「字典」积累的越来越多，也因此两端占用的内存也会越来越大，因此 Web 服务器都会提供类似 **http2_max_requests** 的配置，用于限制一个连接上能够传输的请求数量，避免动态表无限增大，当请求数量到达上限后，就会关闭 HTTP/2 连接来释放内存。

**（3）Huffman 编码**

「Huffman 编码」的原理是将「高频出现的信息」用「较短」的编码表示，从而缩减字符串长度。

### 6.2.3 二进制帧

HTTP/2 不再像 HTTP/1.1 里的纯文本形式的报文，而是全面采用了二进制格式，头信息和数据体都是二进制，并且统称为帧（frame）：头信息帧和数据帧。

这样虽然对人不友好，但是对计算机非常友好，计算机在收到报文后，无需再将明文的报文转成二进制，而是直接解析二进制帧，从而增加了数据传输的效率。

HTTP/2 二进制帧的结构如下图：

<div align="center"> <img src="../pictures//HTTP2二进制帧.webp" width="600"/> </div>

**（1）帧长度**

前 3 个字节表示帧数据（Fream Playload）的长度。

**（2）帧类型**

HTTP/2 总共定义了 10 种类型的帧，分为「数据帧」和「控制帧」两类，如下表所示：

<div align="center"> <img src="../pictures//HTTP2二进制帧帧类型.webp" /> </div>

**（3）标志位**

用于携带简单的控制信息，比如：

- END_HEADERS：表示头数据结束标志，相当于 HTTP/1 里头后的空行（“\r\n”）；
- END_STREAM：表示单方向数据发送结束，后续不会再有数据帧；
- PRIORITY：表示流的优先级。

**（4）流标识符**

用来标识该 Fream 属于哪个 Stream，接收方可以根据这个信息从乱序的帧里找到相同 Stream ID 的帧，从而有序组装信息。

**（5）帧数据**

存放的是通过 HPACK 算法压缩过的 HTTP 头部和请求体。

### 6.2.4 多路复用
 
每个请求或回应的所有数据包，称为一个数据流（Stream），HTTP/2 采用「多个 Stream 可复用一条 TCP 连接」的方式，并且不同 Stream 的帧是可以乱序发送的（因此可以并发处理不同的 Stream），去解决「HTTP 队头阻塞」的问题，加上复用 TCP 的原因，极大的减少了 TCP 连接的使用数量。

TCP 连接、Stream、Message、Frame 的关系如下：

- 1 个 TCP 连接包含一个或者多个 Stream；
- Stream 里可以包含 1 个或多个 Message，Message 对应 HTTP/1 中的请求或响应，由 HTTP 头部和包体构成；
- Message 里包含一条或者多个 Frame，Frame 是 HTTP/2 最小单位，以二进制压缩格式存放 HTTP/1 中的内容（头部和包体）。

> 如何找到乱序中正确的消息呢？

每个帧的头部会携带 Stream ID 信息，接收端通过 Stream ID 去有序组装成 HTTP 消息，**而同一 Stream 内部的帧必须是严格有序的**。

**客户端和服务器双方都可以建立 Stream**， Stream ID 也是有区别的，客户端建立的 Stream 必须是奇数号，而服务器建立的 Stream 必须是偶数号。

同一个连接中的 Stream ID 是不能复用的，只能顺序递增，所以当 Stream ID 耗尽时，需要发一个控制帧 **GOAWAY**，用来关闭 TCP 连接。

HTTP/2 还可以对每个 Stream 设置不同优先级，帧头中的「标志位」可以设置优先级，比如客户端访问 HTML/CSS 和图片资源时，希望服务器先传递 HTML/CSS，再传图片，那么就可以通过设置 Stream 的优先级来实现，以此提高用户体验。

### 6.2.5 服务器主动推送资源

HTTP/2 还在一定程度上改善了传统的「请求 - 应答」工作模式，服务不再是被动地响应，也可以主动向客户端发送消息。

例如：在浏览器刚请求 HTML 的时候，就提前把可能会用到的 JS、CSS 文件等静态资源主动发给客户端，减少延时的等待，也就是服务器推送（Server Push，也叫 Cache Push）。

那 HTTP/2 的推送是怎么实现的？

在响应 HTML 请求时，使用帧类型为 **PUSH_PROMISE** 的帧传输 HTTP 头部，并通过帧中的 **Promised Stream ID** 字段告知客户端，接下来会在哪个偶数号 Stream 中发送主动推送的资源。

## 6.3 HTTP/3

### 6.3.1 HTTP/2 的性能瓶颈

HTTP/2 使用的是 TCP 连接，由于 TCP 连接自身的特性，天然存在这 3 个缺陷：

- TCP 队头阻塞：HTTP/2 由于多个 HTTP 请求在复用一个 TCP 连接，下层的 TCP 协议是不知道有多少个 HTTP 请求的，因此一旦发生了丢包现象，就会触发 TCP 的重传机制，这就导致在一个 TCP 连接中的所有的 HTTP 请求都必须等待这个丢了的包被重传回来才能继续进行发送。
- 握手时延迟：发起 HTTP 请求时，需要经过 TCP 三次握手和 TLS 四次握手（TLS 1.2）的过程，因此共需要 3 个 RTT（round-trip time）的时延才能发出请求数据。
- 网络迁移需要重新连接：一个 TCP 连接是由四元组（源 IP 地址，源端口，目标 IP 地址，目标端口）确定的，这意味着如果 IP 地址或者端口变动了，就会导致需要 TCP 与 TLS 重新握手，这不利于移动设备切换网络的场景，比如 4G 网络环境切换成 WIFI。

所以 HTTP/3 把 HTTP 下层的 TCP 协议改成了 UDP 协议。

### 6.3.2 QUIC 协议

首先 UDP 是一个简单、不可靠的传输协议，而且是 UDP 包之间是无序的，也没有依赖关系，那如何解决这个问题呢？

HTTP/3 的做法是基于 UDP 在「应用层」实现了「QUIC 协议」，去做到实现类似 TCP 的可靠性传输。

QUIC 协议的优点有很多，这里举例几个，例如：

- 无队头阻塞；
- 更快的连接建立；
- 连接迁移。

#### 6.3.2.1 无队头阻塞

QUIC 协议也有类似 HTTP/2 Stream 与多路复用的概念，也是可以在同一条连接上并发传输多个 Stream，Stream 可以认为就是一条 HTTP 请求。

QUIC 协议会保证数据包的可靠性。每个数据包都有一个序号唯一标识，当某个流中的一个数据包丢失了，即使该流的其他数据包到达了，数据也无法被 HTTP/3 读取，直到 QUIC 重传丢失的报文，数据才会交给 HTTP/3。

而其他流的数据报文只要被完整接收，HTTP/3 就可以读取到数据。这与 HTTP/2 不同，HTTP/2 只要某个流中的数据包丢失了，其他流也会因此受影响。

所以，QUIC 连接上的多个 Stream 之间并没有依赖，都是独立的，某个流发生丢包了，只会影响该流，其他流不受影响。

#### 6.3.2.2 更快的连接建立

对于 HTTP/2 协议之前，HTTPS 要建立一个连接，要花费 6 次交互，先是 TCP 三次握手，然后是 TLS/1.3 的三次握手，共有 3-RTT 的时延。

而 HTTP/3 在传输数据前虽然需要 QUIC 协议握手，但握手过程只需要 1 RTT，握手的目的是为确认双方的「连接 ID」，连接迁移就是基于连接 ID 实现的。

并且 QUIC 内部包含并使用的是 TLS/1.3（头部压缩算法升级成了「QPack」），通过在握手的同时带上 TLS 的信息，仅需 1 个 RTT 就可以「同时」完成建立连接与密钥协商，减少了交互次数。

#### 6.3.2.3 连接迁移

QUIC 协议由于是通过「连接 ID」来标记通信的两个端点，因此即使移动设备的网络变化后，导致 IP 地址变化了，只要仍保有上下文信息（比如连接 ID、TLS 密钥等），依旧可以“无缝”地复用原连接，消除重连的成本，从而做到连接迁移。

### 6.3.3 HTTP/3 协议结构

HTTP/3 同 HTTP/2 一样采用二进制帧的结构，不同的地方在于 HTTP/2 的二进制帧里需要定义 Stream，而 HTTP/3 自身不需要再定义 Stream，直接使用 QUIC 里的 Stream，于是 HTTP/3 的帧的结构也变简单了。

<div align="center"> <img src="../pictures//HTTP2和3帧格式对比.webp"/> </div>

HTTP/3 在头部压缩算法这一方便也做了升级，升级成了 **QPACK**。与 HTTP/2 中的 HPACK 编码方式相似，HTTP/3 中的 QPACK 也采用了静态表、动态表及 Huffman 编码。

对于静态表的变化，HTTP/2 中的 HPACK 的静态表只有 61 项，而 HTTP/3 中的 QPACK 的静态表扩大到 91 项。HTTP/2 和 HTTP/3 的 Huffman 编码并没有多大不同，但是动态表编解码方式不同。

由于动态表是具有时序性的，如果首次出现的请求发生了丢包，后续的收到请求，对方就无法解码出 HPACK 头部，因为对方还没建立好动态表，因此后续的请求解码会阻塞到首次请求中丢失的数据包重传过来。

而 QPACK 是如何解决的呢？

QUIC 会有两个特殊的单向流，所谓的单项流只有一端可以发送消息，双向则指两端都可以发送消息，传输 HTTP 消息时用的是双向流，接下来看看这两个单向流的用法：

- 一个叫 QPACK Encoder Stream，用于将一个字典（key-value）传递给对方，比如面对不属于静态表的 HTTP 请求头部，客户端可以通过这个 Stream 发送字典；
- 一个叫 QPACK Decoder Stream，用于响应对方，告诉它刚发的字典已经更新到自己的本地动态表了，后续就可以使用这个字典来编码了。

这两个特殊的单向流是用来同步双方的动态表，编码方收到解码方更新确认的通知后，才使用动态表编码 HTTP 头部。

# 七、Socket

所谓 Socket（套接字），就是对网络中不同主机上的应用进程之间进行双向通信的抽象，它主要有以下作用：

1. 定义了一种应用层进程利用网络协议交换数据的通用机制；
2. 屏幕掉网络协议栈的使用细节，操作系统一般提供常用协议的支持：创建 Socket 的时候，可以指定网络层使用的是 IPv4 还是 IPv6，传输层使用的是 TCP、UDP，还是本地进程间通信。

基于 Linux 一切皆文件的理念，在内核中 Socket 本质上是以「文件」的形式存在的。

这里主要看一下TCP 协议通信的 Socket 编程模型：

> Socket 连接流程

<div align="center"> <img src="../pictures//Socket流程.webp" width="700"/> </div>

1. 服务端和客户端初始化 **socket**，得到文件描述符；
2. 服务端调用 **bind**，将 Socket 绑定在 IP 地址和端口；
3. 服务端调用 **listen**，进行监听；
4. 服务端调用 **accept**，等待客户端连接；
5. 客户端调用 **connect**，向服务器端的地址和端口发起连接请求；
6. 服务端 **accept** 返回用于传输的 **socket** 的文件描述符；
7. 客户端调用 **write** 写入数据；服务端调用 **read** 读取数据；
8. 客户端断开连接时，会调用 **close**，那么服务端 **read** 读取数据的时候，就会读取到了 **EOF**，待处理完数据后，服务端调用 **close**，表示连接关闭。

在 TCP 连接的过程中，服务器的内核实际上为每个 Socket 维护了两个队列：

- 一个是还没完全建立连接的队列，称为「TCP 半连接队列」，这个队列都是没有完成三次握手的连接，此时服务端处于 **syn_rcvd** 的状态；
- 一个是一件建立连接的队列，称为「TCP 全连接队列」，这个队列都是完成了三次握手的连接，此时服务端处于 **established** 状态。

在服务端调用 **accept** 并连接成功后会从 **TCP 全连接队列** 里拿出一个「已完成连接的 Socket」返回给应用程序，用于后续传输数据。

> Socket 在 TCP 握手中的体现。

<div align="center"> <img src="../pictures//Socket在TCP握手中的体现.webp" width="700"/> </div>

我们可以看到客户端 connect 成功返回是在第二次握手，服务端 accept 成功返回是在三次握手成功之后。

> Socket 在 TCP 挥手中的体现。

<div align="center"> <img src="../pictures//Socket在TCP挥手中的体现.webp" width="630"/> </div>

EOF 表示在该连接上再无额外数据到达。当服务端接收到了 FIN 报文，**EOF** 会放在已排队等候的其他已接收的数据之后，在处理完其它已接收的数据之后，就会读到 **EOF**，这是服务端就会调用 **close** 关闭它的套接字。

# 八、TCP 

TCP 协议的结构如下图所示：

<div align="center"> <img src="../pictures//TCP报文头部.webp" width="600"/> </div>

- 源端口号和目标端口：数据的来源端口号和去向端口号；
- 序号：解决包乱序的问题。用来拼接收到的报文段；
- 确认序列：解决不丢包的问题。用于确认发出去的报文对方是否有收到，如果没有收到就应该重新发送，直到送达；
- 状态位：例如「SYN」是发起一个连接，「ACK」是回复，「RST」是重新连接，「FIN」是结束连接等。TCP 是面向连接的，因而双方要维护连接的状态，这些带状态位的包的发送，会引起双方的状态变更；
- 窗口大小：TCP 要做「流量控制」，通信双方各声明一个窗口（缓存大小），标识自己当前能够处理数据的能力；
- 数据：例如使用的是 HTTP 协议，则按照 HTTP 协议拼接 HTTP 头部 + HTTP 报文。

## 8.1 三次握手

首先看一下三次握手的过程：

1. 客户端发送三次握手的第一个 TCP 报文，其中序列号为随机初始化的序号（client_isn），**SYN** 标志位置为 1，之后客户端处于 **SYN-SENT** 状态；
2. 服务端收到客户端的 SYN 报文后，发送第二个 TCP 报文给客户端：服务端也随机初始化自己的序号（server_isn），其次把 TCP 首部的「确认序列」字段填入 client_isn + 1，接着把 SYN 和 ACK 标志位置为 1，之后服务端处于 **SYN-RCVD** 状态；
3. 客户端收到服务端报文后，再向服务端回应第三个应答报文，首先该应答报文 TCP 首部 **ACK** 标志位置为 1，其次「确认序列」字段填入 server_isn + 1，**这次报文可以携带客户端到服务器的数据**，之后客户端处于 **ESTABLISHED** 状态；
4. 服务器收到客户端的应答报文后，也进入 **ESTABLISHED** 状态。

接下来分析三次握手的原因：

- 三次握手才可以阻止重复历史连接的初始化（主要原因）；
- 三次握手后双方才完全掌握当前的握手状态（确保双方都确认对方能收发数据）。

**（1）防止旧的重复连接初始化造成混乱**

假设客户端连续发送多次 SYN 建立连接的报文，在 **网络拥堵** 情况下：

- 一个「旧 SYN 报文」比「最新的 SYN」报文早到达了服务端；
- 那么此时服务端就会回一个 SYN + ACK 报文给客户端；
- 客户端收到后可以根据自身的上下文，判断这是一个历史连接（序列号过期或超时），那么客户端就会发送 **RST** 报文给服务端，表示中止这一次连接，反之发送的报文是 **ACK** 报文，通信双方就会成功建立连接。

**（2）三次握手后双方才完全掌握当前的握手状态**

TCP 协议的通信双方，都必须维护一个「序列号」，序列号是可靠传输的一个关键因素，它的作用：

- 接收方可以去除重复的数据；
- 接收方可以根据数据包的序列号按序接收；
- 可以标识发送出去的数据包中，哪些是已经被对方收到的。

即主要是使服务端和客户端双方都能了解到这次连接的状态，去决定该做什么事情。

## 8.2 四次挥手

双方都可以主动断开连接，断开连接后主机中的「资源」将被释放。

首先看一下四次挥手的过程：

1. 客户端打算关闭连接，此时会发送一个 TCP 首部 **FIN** 标志位被置为 1 的报文，也就是 **FIN** 报文，之后客户端进入 **FIN_WAIT_1** 状态；
2. 服务端收到该报文后，就向客户端发送 **ACK** 应答报文，接着服务端进入 **CLOSED_WAIT** 状态；
3. 客户端收到服务端的 **ACK** 应答报文后，之后进入 **FIN_WAIT_2** 状态；
4. 等待服务端处理完数据后，也向客户端发送 **FIN** 报文，之后服务端进入 **LAST_ACK** 状态；
5. 客户端收到服务端的 **FIN** 报文后，回一个 **ACK** 应答报文，之后进入 **TIME_WAIT** 状态；
6. 服务器收到了 **ACK** 应答报文后，就进入了 **CLOSED** 状态，至此服务端已经完成连接的关闭；
7. 客户端在经过 **2MSL** 一段时间后，自动进入 **CLOSED** 状态，至此客户端也完成连接的关闭。

> 为什么挥手需要四次？

关闭连接时，客户端向服务端发送 **FIN** 时，仅仅表示客户端不再发送数据了，服务端通常需要等待完成数据的发送和处理，所以服务端的 **ACK**和 **FIN** 一般都会分开发送。

> 为什么 TIME_WAIT 等待的时间是 2MSL？

- MSL（Maximum Segment Lifetime）：报文最大生存时间，它是任何报文在网络上存在的最长时间，超过这个时间报文将被丢弃。

保证双方的连接都可以正常的关闭。

例如，客户端回的 **ACK** 应答报文服务端没有收到，服务端会重发 **FIN**，这一来一回最大为 2MSL 时间。需要注意的是该时间是客户端接收到 FIN 后并发送 ACK 后开始计时的（会重置）。

- TTL（Time To Live）：IP 头中有一个 TTL 字段，是 IP 数据报可以经过的最大路由数，每经过一个处理他的路由器此值就减 1，当此值为 0 则数据报将被丢弃，同时发送 ICMP 报文通知源主机。

## 8.3 TCP 的原理和优化

TCP 是通过 **重传机制、滑动窗口、流量控制、拥塞控制** 等机制实现可靠性传输的。

### 8.3.1 重传机制

TCP 实现可靠传输的方式之一，是通过序列号与确认应答。

但在错综复杂的网络，常常会发生数据包丢失的情况，就会用 **重传机制** 解决。

常见的重传机制有以下几种：

- 超时重传；
- 快速重传；
- SACK；
- D-SACK。

#### 8.3.1.1 超时重传

在发送数据时，会设定一个定时器，当超过指定的时间后，没有收到对方的 ACK 确认应答报文，就会重发该数据，也就是我们常说的超时重传。

TCP 会在以下两种情况发生超时重传：

- 数据包丢失；
- 确认应答丢失。

> 这个超时时间设置为多少合适？

这里先说 2 个概念名词：

- RTT（Round-Trip Time）往返时延： **消息的发送 + 接收 ACK 应答的时间总和**；
- RTO（Retransmission Timeout）超时重传时间。

理论上 RTO 的值略大于 RTT 的值最合适，但因为我们的网络也是时常变化的，所以这个值应该是一个 **动态变化的值**。

RFC6289 建议使用以下的公式计算 RTO，其中 SRTT 是计算平滑的 RTT，DevRTR 是计算平滑的 RTT 与最新 RTT 的差距。

```
（1）首次计算 RTO，其中 R1 为第一次测量的 RTT

STRR = R1
DevRTT = R1 / 2
RTO = μ * SRTT + ∂ * DevRT

（2）后续计算 RTO。

SRTT = SRTT + α * (RTT - SRTT)
DevRTT = (1 - β) * DevRTT + β * (|RTT - SRTT|)
RTO = μ * SRTT + ∂ * DevRT

```

在 Linux 下，α = 0.125，β = 0.25，μ = 1，∂ = 4。

而 TCP 使用的策略比较简单直接：每当遇到一次超时重传的时候，都会将下一次超时时间间隔设为先前值的两倍。两次超时，就说明网络环境差，不再发送。

#### 8.3.1.2 快速重传

TCP 还有另外一种快速重传（Fast Retransmit）机制，它不以时间为驱动，而是以「数据驱动重传」。

<div align="center"> <img src="../pictures//TCP快速重传.webp" width="600"/> </div>

假设发送方发出了 1，2，3，4，5 份数：

- 第一份 Seq1 先送到了，于是就 Ack 回 2；
- 结果 Seq2 因为某些原因没收到，Seq3 到达了，于是还是 Ack 回 2；
- 后面的 Seq4 和 Seq5 都到了，但还是 Ack 回 2，因为 Seq2 还是没有收到；
- 发送端收到了三个 Ack = 2 的确认，就知道 Seq2 还没有收到，就会在定时器过期之前，重传丢失的 Seq2；
- 最后，收到了 Seq2，此时因为 Seq3，Seq4，Seq5 都收到了，于是 Ack 回 6。

即：快速重传的工作方式是当收到「三个相同的 ACK 报文」时，会在定时器过期之前，重传丢失的报文段。

但是它依然面临着另外一个问题。比如对于上面的例子，是重传 Seq2 呢？还是重传 Seq2、Seq3、Seq4、Seq5 呢？因为发送端并不清楚这连续的三个 Ack2 是谁传回来的。

于是就有了「SACK 方法」。

#### 8.3.1.3 SACK 方法  

SACK（Selective Acknowledgment ）选择性确认：需要在 TCP 头部「选项」字段里加一个 **SACK** 的东⻄，它可以将「必要的接收缓存区」发送给发送方，这样发送方就可以知道哪些数据收到了，哪些数据没收到，知道了这些信息，就可以只重传丢失的数据。

下图，发送方收到了三次同样的 ACK 确认报文，于是就会触发快速重发机制，通过 SACK 信息发现只有 200~299 这段数据丢失，则重发时，就只选择了这个 TCP 段进行重发。

<div align="center"> <img src="../pictures//TCPSACK方法.webp" width="600"/> </div>

#### 8.3.1.4 Duplicate SACK

Duplicate SACK 又称 D-SACK，其主要使用了 SACK 来告诉「发送方」有哪些数据被重复接收了，让其不用再重发了。

- 假设「接收方」回给「发送方」的 ACK 丢包了，所以发送方超时后，重发数据包；
- 「接收方」发现数据是重复收到的，回一个 SACK，告知「发送方」该数据已被接收了，从而可以让「发送方」知道，是发出去的包丢了，还是接收方回应的 ACK 包丢了。

### 8.3.2 滑动窗口

窗口大小就是指无需等待确认应答，可以继续发送数据的最大值。

窗口的实现实际上是操作系统开辟的一个缓存空间，发送方主机在等到确认应答返回之前，需要在缓冲区中保留已发送的数据。如果按期收到确认应答，数据就可以从缓存区清除掉。

假设窗口大小为 3 个 TCP 段，那么发送方就可以「连续发送」3 个 TCP 段，并且中途若有 ACK 丢失，可以通过「下一个确认应答进行确认」。

例如：

情景：需要发送 5 份数据，其中第 2 份确认应答报文丢失；
做法：只要发送方收到了第 5 份确认应答，就意味着第五份之前的所有数据「接收方」都收到了。这个模式就叫「累计确认」或者「累计应答」。

> 窗口大小由哪一方决定？

TCP 头里有一个字段叫 Window，也就是窗口大小。

这个字段是接收端告诉发送端自己还有多少缓冲区可以接收数据。于是发送端就可以根据这个接收端的处理能力来发送数据，从而尽可能避免接收端处理不过来的情况。

所以，通常窗口的大小是由接收方的窗口大小来决定的。

> 发送方的滑动窗口

<div align="center"> <img src="../pictures//TCP滑动窗口发送端.webp" width="800"/> </div>

- SND.WND：表示发送窗口的大小（大小是由接收方指定的）；
- SND.UNA：是一个绝对指针，它指向的是已发送但未收到确认的第一个字节的序列号，也就是 #2 的第一个字节；
- SND.NXT：也是一个绝对指针，它指向未发送但可发送范围的第一个字节的序列号，也就是 #3 的第一个字节；
- 指向 #4 的第一个字节是个相对指针，它等于 **SND.UNA** 指针加上 **SND.WND** 大小的偏移量。

那么可用窗口大小为：SND.WND -（SND.NXT - SND.UNA）。

> 接收方的滑动窗口

<div align="center"> <img src="../pictures//TCP滑动窗口接收端.webp" width="800"/> </div>

- RCV.WND：表示接收窗口的大小，它会通告给发送方；
- RCV.NXT：是一个指针，它指向期望从发送方发送来的下一个数据字节的序列号，也就是 #3 的第一个字节；
- 指向 #4 的第一个字节是个相对指针，它等于 **RCV.NXT** 指针加上 **RCV.WND** 大小的偏移量。

> 接收窗口和发送窗口的大小是相等的吗？

并不是完全相等，接收窗口的大小是约等于发送窗口的大小的，因为互发消息存在时延。
  
### 8.3.3 流量控制

TCP 通过让接收方指明希望从发送方接收的数据大小（窗口大小）来进行流量控制。

#### 8.3.3.1 窗口关闭

如果窗口大小为 0 时，就会阻止发送方给接收方传递数据，直到窗口变为非 0 为止，这就是「窗口关闭」。

> 窗口关闭潜在的危险

当发生窗口关闭时，接收方处理完数据后，会向发送方通告一个窗口非 0 的 ACK 报文，如果这个通告窗口的 ACK 报文在网络中丢失了，就会形成死锁的现象：

发送方一直等待接收方的非 0 窗口通知，接收方也一直等待发送方的数据。

如何解决这个问题呢？

TCP 为每个连接设有一个持续定时器，只要 TCP 连接一方 **收到对方的零窗口通知，就启动持续计时器**。当持续计时器超时，就会发送「窗口探测（Windowprobe ）」报文，而对方在确认这个探测报文时，给出自己现在的接收窗口大小。

#### 8.3.3.2 糊涂窗口综合症

如果接收方太忙了，来不及取走接收窗口里的数据，那么就会导致发送方的发送窗口越来越小。

到最后，如果接收方腾出几个字节并告诉发送方现在有几个字节的窗口，而发送方会义无反顾地发送这几个字节，这就是「糊涂窗口综合症」。

要解决这个问题很自然的可以有 2 种思路：

- 接收方不通告小窗口给发送方；
- 发送方不发送小数据。

> 怎么让接收方不通告小窗口呢？

当「窗口大小」小于 min（MSS（最大报文段长度），缓存空间/2）时，就会向发送方通告窗口为 0，也就阻止了发送方再发数据过来。

> 怎么让发送方避免发送小数据呢？

使用 Nagle 算法，该算法的思路是延时处理，它满足以下两个条件中的一条才可以发送数据：

- 要等到 窗口大小/需发送的数据大小 >= MSS;
- 收到之前发送数据的 Ack 回包。

### 8.3.4 拥塞控制

> 流量控制和拥塞控制的区别

流量控制是避免「发送方」的数据填满「接收方」的缓存，但是并不知道实际网络发生了什么。

当网络出现拥堵时，如果继续发送大量数据包，会更容易导致数据包时延、丢失等，这时 TCP 就会重传数据，但是一重传就会导致网络的负担更重，于是会导致更大的延迟以及更多的丢包，这个情况就会进入恶性循环被不断地放大。

于是，就有了拥塞控制，控制的目的就是避免「发送方」的数据填满整个网络。

为了调节「发送方」所要发送数据的量，于是定义了一个叫做「拥塞窗口」的概念。

> 什么是拥塞窗口？和发送窗口有什么关系呢？

「拥塞窗口 cwnd」 是发送方维护的一个的状态变量，它会根据网络的拥塞程度动态变化。

我们在前面提到过 **发送窗口 swnd** 和 **接收窗口 rwnd** 是约等于的关系，那么由于加入了拥塞窗口的概念后，此时发送窗口的值是 swnd = min(cwnd, rwnd)，也就是拥塞窗口和接收窗口中的最小值。

> 怎么知道当前网络是否出现了拥塞呢？

只要「发送方」没有在规定时间内接收到 ACK 应答报文，也就是发生了「超时重传」，就会认为网络出现了拥塞。

> 拥塞控制有哪些控制算法？

慢启动、拥塞避免、拥塞发生、快速恢复。

#### 8.3.4.1 慢启动

TCP 在刚建立连接完成后，首先是有个慢启动的过程，这个慢启动的意思就是一点一点的提高发送数据包的数量，如果一上来就发大量的数据，这不是给网络添堵吗？

慢启动的算法：当发送方每收到一个 ACK，拥塞窗口 cwnd 的大小就会加 1。

即在网络好且拥有足够包的情况下，拥塞窗口 cwnd 的大小会指数性的增长。

> 那慢启动涨到什么时候是个头呢？

有一个叫慢启动⻔限 ssthresh（slow start threshold）状态变量。

- 当 cwnd < ssthresh 时，使用「慢启动算法」；
- 当 cwnd >= ssthresh 时，就会使用「拥塞避免算法」。

#### 8.3.4.2 拥塞避免

一般来说 ssthresh 的大小是 65535 字节。

那么进入拥塞避免算法后，它的规则是：每当收到一个 ACK 时，cwnd 增加 1/cwnd。

所以，拥塞避免算法就是将原本慢启动算法的指数增长变成了线性增长，还是增长阶段，但是增长速度缓慢了一些。

一直增长后，网络就肯能会慢慢进入拥塞的状况，于是就会出现丢包现象，然后触发了重传机制，也就进入了「拥塞发生算法」。

#### 8.3.4.3 拥塞发生

「超时重传」和「快速重传」这两种重传所使用的拥塞发生算法是不同的。

> 超时重传的处理：

- ssthresh 设为 cwnd/2；
- cwnd 重置为 1。

接着，就重新开始慢启动，可以发现一旦「超时重传」，就马上重头开始，也因此可能会造成网络延迟。

> 快速重传的处理：

TCP 认为这种情况不严重，因为大部分没丢，只丢了一小部分，则 ssthresh 和 cwnd 变化如下：

- cwnd = cwnd/2，也就是设置为原来的一半；
- ssthresh = cwnd；
- 进入「快速恢复算法」。

#### 8.3.4.4 快速恢复

进入快速恢复算法如下：

- 拥塞窗口 cwnd = ssthresh + 3（3 的意思是确认有 3 个数据包被收到了）；
- 重传丢失的数据包；
- 如果再收到重复的 ACK，那么 cwnd 增加 1；
- 如果收到新数据的 ACK 后，把 cwnd 设置为第一步中的 ssthresh 的值，原因是该 ACK 确认了新的数据，说明从 duplicated ACK 时的数据都已收到，该恢复过程已经结束，可以回到恢复之前的状态了，即再次进入拥塞避免状态。

# 参考资料

- 上野宣. 图解 HTTP[M]. 人民邮电出版社, 2014.
- [HTTP - CS-Notes](https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/HTTP.md)
- [图解网络](https://mp.weixin.qq.com/mp/appmsgalbum?action=getalbum&album_id=1337204681134751744&__biz=MzUxODAzNDg4NQ==#wechat_redirect)

