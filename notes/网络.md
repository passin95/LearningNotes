
<!-- TOC -->

- [一、计算器网络结构](#一计算器网络结构)
    - [1.1 URI 和 URL](#11-uri-和-url)
    - [1.2 TCP/IP](#12-tcpip)
    - [1.3 从一个 HTTP 请求看计算机网络结构](#13-从一个-http-请求看计算机网络结构)
        - [1.3.1 域名解析](#131-域名解析)
        - [1.3.2 应用层](#132-应用层)
        - [1.3.3 传输层](#133-传输层)
            - [1.3.3.1 TCP](#1331-tcp)
            - [1.3.3.2 UDP](#1332-udp)
        - [1.3.4 网络层](#134-网络层)
        - [1.3.5 数据链路层](#135-数据链路层)
        - [1.3.6 物理层](#136-物理层)
- [二、HTTP](#二http)
    - [2.1 请求报文和响应报文](#21-请求报文和响应报文)
    - [2.2 请求方法](#22-请求方法)
    - [2.3 HTTP 状态码](#23-http-状态码)
        - [2.3.1 1XX 信息](#231-1xx-信息)
        - [2.3.2 2XX 成功](#232-2xx-成功)
        - [2.3.3 3XX 重定向](#233-3xx-重定向)
        - [2.3.4 4XX 客户端错误](#234-4xx-客户端错误)
        - [2.3.5 5XX 服务器错误](#235-5xx-服务器错误)
    - [2.4 HTTP 首部（请求头）](#24-http-首部请求头)
        - [2.4.1 通用首部字段](#241-通用首部字段)
        - [2.4.2 请求首部字段](#242-请求首部字段)
        - [2.4.3 响应首部字段](#243-响应首部字段)
        - [2.4.4 实体首部字段](#244-实体首部字段)
    - [2.5 Content-Type](#25-content-type)
- [三、HTTP 协议实际应用](#三http-协议实际应用)
    - [3.1 Cookie](#31-cookie)
        - [3.1.1 用途](#311-用途)
        - [3.1.2 创建过程](#312-创建过程)
        - [3.1.3 分类](#313-分类)
        - [3.1.4 JavaScript 获取 Cookie](#314-javascript-获取-cookie)
        - [3.1.5 Secure 和 HttpOnly](#315-secure-和-httponly)
        - [3.1.6 Session](#316-session)
        - [3.1.7 浏览器禁用 Cookie](#317-浏览器禁用-cookie)
        - [3.1.8 Cookie 与 Session 选择](#318-cookie-与-session-选择)
    - [3.2 缓存](#32-缓存)
        - [3.2.1 作用](#321-作用)
        - [3.2.2 实现方法](#322-实现方法)
        - [3.2.3 Cache-Control](#323-cache-control)
        - [3.2.4 缓存验证](#324-缓存验证)
    - [3.3 Authorization](#33-authorization)
        - [3.3.1 Basic](#331-basic)
        - [3.3.2 Bearer](#332-bearer)
            - [3.3.2.1 OAuth2 授权流程](#3321-oauth2-授权流程)
            - [3.3.2.2 OAuth2 微信授权登陆流程](#3322-oauth2-微信授权登陆流程)
            - [3.3.2.3 在自家 App 中使用 Bearer token](#3323-在自家-app-中使用-bearer-token)
            - [3.3.2.4 为什么引入 Authorization code](#3324-为什么引入-authorization-code)
            - [3.3.2.5 Refresh token](#3325-refresh-token)
    - [3.4 连接管理](#34-连接管理)
        - [3.4.1 短连接与长连接](#341-短连接与长连接)
        - [3.4.2 管道网络传输](#342-管道网络传输)
    - [3.5 内容协商](#35-内容协商)
        - [3.5.1 类型](#351-类型)
        - [3.5.2 Vary](#352-vary)
    - [3.6 内容编码](#36-内容编码)
    - [3.7 范围请求](#37-范围请求)
        - [3.7.1 Range](#371-range)
        - [3.7.2 Accept-Ranges](#372-accept-ranges)
        - [3.7.3 响应状态码](#373-响应状态码)
    - [3.8 分块传输编码](#38-分块传输编码)
    - [3.9 多部分对象集合](#39-多部分对象集合)
    - [3.10 WebSocket](#310-websocket)
        - [3.10.1 连接过程](#3101-连接过程)
        - [3.10.2 数据帧格式](#3102-数据帧格式)
- [四、HTTPS](#四https)
    - [4.1 加密](#41-加密)
        - [4.1.1 对称密钥加密](#411-对称密钥加密)
        - [4.1.2 非对称密钥加密](#412-非对称密钥加密)
    - [4.2 证书（认证）](#42-证书认证)
        - [4.2.1 证书包含的信息](#421-证书包含的信息)
        - [4.2.2 证书的验证过程](#422-证书的验证过程)
    - [4.3 完整性保护](#43-完整性保护)
    - [4.4 HTTPS 的缺点](#44-https-的缺点)
    - [4.5 HTTPS 连接建立过程](#45-https-连接建立过程)
- [五、GET 和 POST 的区别](#五get-和-post-的区别)
    - [5.1 作用](#51-作用)
    - [5.2 参数](#52-参数)
    - [5.3 安全](#53-安全)
    - [5.4 幂等性](#54-幂等性)
    - [5.5 可缓存](#55-可缓存)
- [六、HTTP/1.1、HTTP/2、HTTP/3](#六http11http2http3)
    - [6.1 HTTP/1.1](#61-http11)
    - [6.2 HTTP/2](#62-http2)
    - [6.3 HTTP/3](#63-http3)
- [参考资料](#参考资料)

<!-- /TOC -->

# 一、计算器网络结构

## 1.1 URI 和 URL

- URI（Uniform Resource Identifier，统一资源标识符）
- URL（Uniform Resource Locator，统一资源定位符）
- URN（Uniform Resource Name，统一资源名称），例如 urn:isbn:0-486-27557-4。

URI 包含 URL 和 URN，目前 WEB 只有 URL 比较流行，所以见到的基本都是 URL。

<div align="center"> <img src="../pictures//URI%20和%20URL%20的关系.webp" /> </div>

URI 的结构如下，它们都是等价的，只不过划分的区域不同：
```
[scheme:]scheme-specific-part[#fragment]
[scheme:][//authority][path][?query][#fragment]
[scheme:][//host:port][path][?query][#fragment]
```

以下用一个 URI 字符串来横向对比各部分结构的区别。

```
http://www.demo.com:8080/path/path1?key=value&key1=value1&key2=value2#demofragment
```

- scheme：URI 的模式，例如 http、file、content 等，Deme 中为 http；
- scheme-specific-part：//www.demo.com:8080/path/path1?key=value&key1=value1&key2=value2；
- authority：www.demo.com:8080；
- host：URI 的主机域名或 IP 地址，Demo 中为 www.demo.com；
- port：端口号，Demo 中为 8080；
- path：路径信息，Demo 中为 /yourpath/fileName.htm；
- query：键对值，Deme 中为 key=value&key1=value1&key2=value2；
- fragment：用来标识次级资源，Demo 中为 demofragment。

## 1.2 TCP/IP

<div align="center"> <img src="../pictures//TCPIP.png" width="400"/> </div>

TCP/IP 是互联网相关的各类协议族的总称。

## 1.3 计算机网络体系结构

计算机网络体系结构如下图所示：

<div align="center"> <img src="../pictures//计算机网络体系结构.webp"/> </div>

分层管理的概念，不管是软件开发还是现实生活中都经常使用的一种手段，由于网络通讯存在种种不稳定的因素，通过单一职责化隔离每一层的作用，这样使上层结构不需要关心下层的来源，只需要对接相关的接口，这样不仅更利于未来的维护，也能从架构层面提高稳定性。

## 1.3 从一个 HTTP 请求看计算机网络结构

一个 HTTP 请求一般经过以下几个过程：

<div align="center"> <img src="../pictures//TCP%20连接过程.webp"/> </div>

### 1.3.1 域名解析

浏览器解析 URL 并生成 HTTP 报文后，需要委托操作系统将消息发送给 Web 服务器，而有一种服务器专门保存了 Web 服务器域名与 IP 的对应关系，它就是 DNS 服务器。

域名服务器的层级关系类似一个树状结构：

<div align="center"> <img src="../pictures//DNS结构.webp" width="500"/> </div>

域名解析的工作流程：

1. 客户端发出一个域名解析的请求：问本地 DNS 服务器（也就是客户端的 TCP/IP 设置中填写的 DNS 服务器地址）「www.server.com」 的 IP 地址是多少。
2. 本地 DNS 服务器收到请求后，先查询缓存中是否能找到对应域名的 IP 地址，如果找到则直接返回；如果没有，本地 DNS 会去问它的根域名服务器，根域名服务器是最高层次的，它不直接用于域名解析。
3. 根域名服务器收到来自本地 DNS 的请求后，发现后缀是 .com，回复道：“www.server.com 这个域名归 .com 区域管理”，我给你 .com 顶级域名服务器地址给你，你去问它吧。”
4. 本地 DNS 收到顶级域名服务器的地址后，发起请求“你能告诉我 www.server.com 的 IP 地址吗？”
5. 顶级域名服务器说：“我给你负责 www.server.com 区域的权威 DNS 服务器的地址，你去问它应该能问到”。
6. 本地 DNS 于是转向问权威 DNS 服务器，为啥叫权威呢？就是我的域名我做主。
7. 权威 DNS 服务器查询后将对应的 IP 地址告诉本地 DNS。
8. 本地 DNS 再将 IP 地址返回客户端，客户端和目标建立连接。

### 1.3.2 应用层

应用层协议定义的是应用进程（进程：主机中正在运行的程序）间的通信和交互的规则，不用去关心数据是如何传输的。对于不同的网络应用需要不同的应用层协议，例如域名系统 DNS，支持万维网应用的 HTTP 协议，支持电子邮件的 SMTP 协议等等。数据单元称为报文。

### 1.3.3 传输层

传输层主要提供数据的传输服务，例如如何在多变的网络条件下保证数据的可靠传输。由于应用层协议很多，定义通用的运输层协议就可以支持不断增多的应用层协议。运输层主要使用两种协议：传输控制协议 TCP 和用户数据报协议 UDP。

#### 1.3.3.1 TCP

TCP 是「面向连接的」、「可靠的」、「基于字节流」的传输层通信协议。

- 面向连接：一定是「一对一」才能连接，不能像「UDP 协议」可以一个主机同时向多个主机发送消息；
- 可靠的：无论的网络链路中出现了怎样的链路变化，TCP 都可以保证一个报文一定能够到达接收端；
- 字节流：消息是「没有边界」的，无论我们消息有多大都可以进行传输。并且消息是「有序的」，当「前一个」消息没有收到的时候，即使它先收到了后面的字节已经收到，那么也不能扔给应用层去处理，同时对「重复」的报文会自动丢弃。

通信双方在进行通信之前，需要通过三次握手建立连接，确认双方都具有数据收发的能力。

TCP 提供了确认应答、超时重传、滑动窗口、流量控制、慢启动、拥塞机制等机制来保证数据有序及可靠性，数据单位为报文段。它的原理是对收到的数据（例如 HTTP 请求报文）进行分割，并在各个报文上打上标记序号及端口号后转发给网络层。每一条 TCP 连接只能是点到点的。

TCP 协议的结构如下图所示：

<div align="center"> <img src="../pictures//TCP报文头部.webp" width="500"/> </div>

- 源端口号和目标端口：数据的来源端口号和去向端口号；
- 序号：解决包乱序的问题。用来拼接收到的报文段；
- 确认序列：解决不丢包的问题。用于确认发出去的报文对方是否有收到，如果没有收到就应该重新发送，直到送达。
- 状态位：例如「SYN」是发起一个连接，「ACK」是回复，「RST」是重新连接，FIN 是结束连接等。TCP 是面向连接的，因而双方要维护连接的状态，这些带状态位的包的发送，会引起双方的状态变更。
- 窗口大小：TCP 要做「流量控制」，通信双方各声明一个窗口（缓存大小），标识自己当前能够处理数据的能力。
- 数据：例如使用的是 HTTP 协议，则按照 HTTP 协议拼接 HTTP 头部 + HTTP 报文。

#### 1.3.3.2 UDP

UDP 是一个「无连接」、「不保证可靠交付」、「支持一对多」的协议。

- 无连接：发送数据前，双方无需建立连接，数据发送完毕后，也无需断开连接（没有连接和断开），这样一来，减少了连接和断开连接的开销（无需像 TCP 连接时需要三次握手，断开连接时需要四次挥手）；
- 不保证可靠交付：它会尽最大努力提供数据传输服务（即不保证可靠交付），数据单位为用户数据报，适用于对高速传输和实时性有较高的通信或广播通信；
- 支持一对多：UDP 支持一对一，一对多，多对一和多对多的交互通信，多用于实时游戏、视频通话等。

UDP 协议比较简单，头部只有 8 个字节，结构如下图所示：

<div align="center"> <img src="../pictures//UDP协议.webp" width="500"/> </div>

- 源端口号和目的端口号：数据的来源和去向。
- 包长度：该字段保存了 UDP 首部的长度跟数据的长度之和。
- 校验和：校验和是为了提供可靠的 UDP 首部和数据而设计。

为什么 UDP 头部没有「首部长度」字段，而 TCP 头部有「首部长度」字段呢？

- 原因是 TCP 有可变长的「选项」字段，而 UDP 头部长度则是不会变化的，无需多一个字段去记录 UDP 的首部长度。

为什么 UDP 头部有「包长度」字段，而 TCP 头部则没有「包长度」字段呢？

因为 TCP 的负载数据长度是可以计算的：

TCP 数据的长度 = IP 总长度 - IP 首部长度 - TCP 首部长度。

其中 IP 总长度 和 IP 首部长度，在 IP 首部格式是已知的。TCP 首部长度，则是在 TCP 首部格式已知的，所以就可以求得 TCP 数据的长度。

### 1.3.4 网络层

网络层只负责网络地址将源结点发出的数据包传送到目的结点。该层控制数据链路层与传输层之间的信息转发、建立、维持和终止网络的连接。该层一般是 IP 协议。

IP 协议的结构如下图所示：

<div align="center"> <img src="../pictures//IP协议.webp" width="500"/> </div>


- 协议：所使用的传输层协议，例如 TCP 协议；
- 源 IP 地址和目标 IP 地址：数据来源和目标的 IP 地址。

接下来网络包还需要在 IP 头部的前面加上 MAC 头部，用于在「以太网」中传输。

MAC 协议包括了以下三个信息：

- 发送方的 MAC 地址：从发送端的网卡 ROM 中取出来写入到 MAC 头部；
- 接收方的 MAC 地址：需要「ARP 协议」帮我们找到路由器的 MAC 地址。ARP 协议会在以太网中以「广播」的形式询问所有设备某 IP 地址所对应的 MAC 地址是多少；
- 协议类型：一般为 IP 协议（0800）或 ARP 协议（0806）。

至此，网络包的报文如下图：

<div align="center"> <img src="../pictures//网络包报文.webp" width="700"/> </div>

### 1.3.5 数据链路层

物理层的线路由传输介质与通信设备组成，比特流在传输介质上传输时肯定会存在误差的。这样就引入了数据链路层在物理层之上，采用差错检测、差错控制和流量控制等方法，向网络层提供高质量的数据传输服务。

数据链路层必须具备一系列相应的功能，主要有：

1. 如何将数据组合成数据块，在数据链路层中称这种数据块为帧，帧是数据链路层的传送单位；
2. 如何控制帧在物理信道上的传输，包括如何处理传输差错。
3. 如何调节发送速率以使与接收方相匹配；以及在两个网络实体之间提供数据链路通路的建立、维持和释放的管理。

负责执行这一操作的是网卡，要控制网卡还需要靠网卡驱动程序。

网卡驱动从 IP 模块获取到包之后，会将其复制到网卡内的缓存区中，接着会其开头加上报头和起始帧分界符，在末尾加上用于检测错误的帧校验序列。最后网卡会将包转为电信号，通过网线发送出去。

### 1.3.6 物理层

生成的网络包只是存放在内存中的一串二进制数字信息，没有办法直接发送给对方。因此，我们需要将「数字信息转换为电信号」，才能在网线上传输，也就是说，这才是真正的数据发送过程。

这也是物理层的作用，主要是为数据链路层提供二进制传输的服务。

# 二、HTTP

- 超文本传输协议，现用于作为网络请求以及传输 HTML 内容、二进制数据等。
- HTTP 位于 TCP/IP 协议族中的最顶层———应用层

## 2.1 请求报文和响应报文

**（1）请求报文**

<div align="center"> <img src="../pictures//HTTP%20请求报文.png"/> </div><br>

**（2）响应报文**

<div align="center"> <img src="../pictures//HTTP%20响应报文.png"/> </div><br>

## 2.2 请求方法

**（1）GET**

- 用于获取资源。
- 不会修改服务器数据。
- 不发送 Body。

**（2）HEAD**

- 用于获取报文首部，即返回的响应没有 Body。

**（3）POST**

- 用于增加或修改资源。
- 传输内容写在 Body 中。

**（4）PUT**

- 向指定资源位置上传其最新内容。
- 传输内容写在 Body 中。

**（4）DELETE**

- 删除指定资源位置的资源。
- 请求报文没有请求体。

## 2.3 HTTP 状态码

服务器返回的 **响应报文** 中第一行为状态行，包含了状态码以及原因短语，用来告知客户端请求的结果。

| 状态码 | 类别 | 原因短语 |
| :---: | :---: | :---: |
| 1XX | Informational（信息性状态码） | 接收的请求正在处理 |
| 2XX | Success（成功状态码） | 请求正常处理完毕 |
| 3XX | Redirection（重定向状态码） | 需要进行附加操作以完成请求 |
| 4XX | Client Error（客户端错误状态码） | 服务器无法处理请求 |
| 5XX | Server Error（服务器错误状态码） | 服务器处理请求出错 |

### 2.3.1 1XX 信息

-  **100 Continue** ：表明到目前为止都很正常，客户端可以继续发送请求 (例如传输文件过大，需要分段传输，服务器返回 100 表示已经接受到客户端的需要，让客户端继续传输) 或者忽略这个响应。

### 2.3.2 2XX 成功

-  **200 OK** 

-  **204 No Content** ：请求已经成功处理，但是返回的响应报文不包含实体的主体部分。一般在只需要从客户端往服务器发送信息，而不需要返回数据时使用。

-  **206 Partial Content** ：表示客户端进行了范围请求。响应报文包含由 Content-Range 指定范围的实体内容。

### 2.3.3 3XX 重定向

-  **301 Moved Permanently** ：永久性重定向

-  **302 Found** ：临时性重定向

-  **303 See Other** ：和 302 有着相同的功能，但是 303 明确要求客户端应该采用 GET 方法获取资源。

- 注：虽然 HTTP 协议规定 301、302 状态下重定向时不允许把 POST 方法改成 GET 方法，但是大多数浏览器都会在 301、302 和 303 状态下的重定向把 POST 方法改成 GET 方法。

-  **304 Not Modified** ：如果请求报文首部包含一些条件，例如：If-Match，If-Modified-Since，If-None-Match，If-Range，If-Unmodified-Since，如果如果网页自请求者上次请求后再也没有更改过，则服务器会返回 304 状态码。

-  **307 Temporary Redirect** ：临时重定向，与 302 的含义类似，但是 307 要求浏览器不会把重定向请求的 POST 方法改成 GET 方法。

### 2.3.4 4XX 客户端错误

-  **400 Bad Request** ：请求报文中存在语法错误。

-  **401 Unauthorized** ：该状态码表示发送的请求需要有认证信息（BASIC 认证、DIGEST 认证）。如果之前已进行过一次请求，则表示用户认证失败。

-  **403 Forbidden** ：请求被拒绝，服务器端没有必要给出拒绝的详细理由。

-  **404 Not Found** ：请求地址不存在。

-  **407 Proxy Authentication Required** ：需要代理授权，和 401 类似，但指定请求者应当授权使用代理。

### 2.3.5 5XX 服务器错误

-  **500 Internal Server Error** ：服务器正在执行请求时发生错误。

-  **503 Service Unavailable** ：服务器暂时处于超负载或正在进行停机维护，现在无法处理请求。

## 2.4 HTTP 首部（请求头）

有 4 种类型的首部字段：通用首部字段、请求首部字段、响应首部字段和实体首部字段。

各种首部字段及其含义如下（不需要全记，仅供查阅）：

### 2.4.1 通用首部字段

| 首部字段名 | 说明 |
| :--: | :--: |
| Cache-Control | 控制缓存的行为 |
| Connection | 控制不再转发给代理的首部字段、管理持久连接|
| Date | 创建报文的日期时间 |
| Pragma | 报文指令 |
| Trailer | 报文末端的首部一览 |
| Transfer-Encoding | 指定报文主体的传输编码方式 |
| Upgrade | 升级为其他协议 |
| Via | 代理服务器的相关信息 |
| Warning | 错误通知 |

### 2.4.2 请求首部字段

| 首部字段名 | 说明 |
| :--: | :--: |
| Accept | 用户代理可处理的媒体类型 |
| Accept-Charset | 优先的字符集 |
| Accept-Encoding | 优先的内容编码 |
| Accept-Language | 优先的语言（自然语言） |
| Authorization | Web 认证信息 |
| Expect | 期待服务器的特定行为 |
| From | 用户的电子邮箱地址 |
| Host | 请求资源所在服务器 |
| If-Match | 比较实体标记（ETag） |
| If-Modified-Since | 比较资源的更新时间 |
| If-None-Match | 比较实体标记（与 If-Match 相反） |
| If-Range | 资源未更新时发送实体 Byte 的范围请求 |
| If-Unmodified-Since | 比较资源的更新时间（与 If-Modified-Since 相反） |
| Max-Forwards | 最大传输逐跳数 |
| Proxy-Authorization | 代理服务器要求客户端的认证信息 |
| Range | 实体的字节范围请求 |
| Referer | 对请求中 URI 的原始获取方 |
| TE | 传输编码的优先级 |
| User-Agent | 用户代理 |

### 2.4.3 响应首部字段

| 首部字段名 | 说明 |
| :--: | :--: |
| Accept-Ranges | 是否接受字节范围请求 |
| Age | 推算资源创建经过时间 |
| ETag | 资源的匹配信息 |
| Location | 令客户端重定向至指定 URI |
| Proxy-Authenticate | 代理服务器对客户端的认证信息 |
| Retry-After | 对再次发起请求的时机要求 |
| Server | HTTP 服务器的安装信息 |
| Vary | 代理服务器缓存的管理信息 |
| WWW-Authenticate | 服务器对客户端的认证信息 |

### 2.4.4 实体首部字段

| 首部字段名 | 说明 |
| :--: | :--: |
| Allow | 资源可支持的 HTTP 方法 |
| Content-Encoding | 实体主体适用的编码方式 |
| Content-Language | 实体主体的自然语言 |
| Content-Length | 实体主体的大小 |
| Content-Location | 替代对应资源的 URI |
| Content-MD5 | 实体主体的报文摘要 |
| Content-Range | 实体主体的位置范围 |
| Content-Type | 实体主体的媒体类型 |
| Expires | 实体主体过期的日期时间 |
| Last-Modified | 资源的最后修改日期时间 |

## 2.5 Content-Type

**（1）text/html**

Body 中返回 html 文本。

**（2）x-www-form-urlencoded**

纯文本表单的提交方式。

**（3）multitype/form-data**

含二进制文件时的提交方式。

**（4）application/json，image/jpeg,……**

单项（专项）内容提交，例如 application/json 可直接以 Body 形式传输相应 bean 类。

# 三、HTTP 协议实际应用

## 3.1 Cookie

HTTP 协议是无状态的，主要是为了让 HTTP 协议尽可能简单。为了让它能够处理大量事务，在 HTTP/1.1 中引入 Cookie 来保存状态信息。

Cookie 是服务器发送到用户浏览器并保存在本地的一小块数据，浏览器向同一服务器再次发起请求时 Cookie 会被携带上，用于告知服务端两个请求是否来自同一浏览器。由于之后每次请求都会需要携带 Cookie 数据，因此会带来额外的性能开销（尤其是在移动环境下）。

Cookie 曾一度用于客户端数据的存储，因为当时并没有其它合适的存储办法而作为唯一的存储手段，但现在随着现代浏览器开始支持各种各样的存储方式，Cookie 渐渐被淘汰，但 Cookie 在其它用途上面仍有用武之地。

### 3.1.1 用途

- 会话状态管理（如用户登录状态、购物车、游戏分数或其它需要记录的信息）
- 个性化设置（如用户自定义设置、主题等）
- 浏览器行为跟踪（如跟踪分析用户行为等）

### 3.1.2 创建过程

服务器发送的响应报文包含 Set-Cookie 首部字段，客户端得到响应报文后把 Cookie 内容保存到浏览器（客户端）中。

```html
HTTP/1.1 200 OK
Content-type: text/html
Set-Cookie: yummy_cookie=choco
Set-Cookie: tasty_cookie=strawberry
```

客户端之后对同一个服务器发送请求时，从浏览器中读出 Cookie 信息通过添加 Cookie 请求首部字段发送给服务器。

```html
GET /sample_page.html HTTP/1.1
Host: www.example.org
Cookie: yummy_cookie=choco; tasty_cookie=strawberry
```

### 3.1.3 分类

- 会话期 Cookie：浏览器关闭之后它会被自动删除，也就是说它仅在会话期内有效。
- 持久性 Cookie：指定一个特定的过期时间（Expires）或有效期（max-age）。

```html
Set-Cookie: id=a3fWa; Expires=Wed, 21 Oct 2015 07:28:00 GMT;
```

### 3.1.4 JavaScript 获取 Cookie

通过 `Document.cookie` 属性可创建新的 Cookie，也可通过该属性访问非 HttpOnly 标记的 Cookie。

```html
document.cookie = "yummy_cookie=choco";
document.cookie = "tasty_cookie=strawberry";
console.log(document.cookie);
```

### 3.1.5 Secure 和 HttpOnly

标记为 Secure 的 Cookie 只应通过被 HTTPS 请求发送给服务端。但即便设置了 Secure 标记，敏感信息也不应该通过 Cookie 传输，因为 Cookie 有其固有的不安全性，Secure 标记也无法提供绝对的安全保障。

标记为 HttpOnly 的 Cookie 不能被 JavaScript 脚本调用。因为跨站脚本攻击 (XSS) 常常使用 JavaScript 的 `Document.cookie` API 窃取用户的 Cookie 信息，因此使用 HttpOnly 标记可以在一定程度上避免 XSS 攻击。

```html
Set-Cookie: id=a3fWa; Expires=Wed, 21 Oct 2015 07:28:00 GMT; Secure; HttpOnly
```

### 3.1.6 Session

除了可以将用户信息通过 Cookie 存储在用户浏览器中，也可以利用 Session 存储在服务器端，存储在服务器端的信息也会更加安全。

Session 可以存储在服务器上的文件、数据库或者内存中。也可以将 Session 存储在内存型数据库中，比如 Redis。

使用 Session 维护用户登录的过程如下：

- 用户进行登录时，用户提交包含用户名和密码的表单，放入 HTTP 请求报文中；
- 服务器验证该用户名和密码；
- 如果正确则把用户信息存储到 Redis 中，它在 Redis 中的 ID 称为 Session ID；
- 服务器返回的响应报文的 Set-Cookie 首部字段包含了这个 Session ID，客户端收到响应报文之后将该 Cookie 值存入浏览器中；
- 客户端之后对同一个服务器进行请求时会包含该 Cookie 值，服务器收到之后提取出 Session ID，从 Redis 中取出用户信息，继续之后的业务操作。

应该注意 Session ID 的安全性问题，不能让它被恶意攻击者轻易获取。因此 Session ID 的生成规则应当是不规律的，且还需要经常重新生成 Session ID。在对安全性要求极高的场景下，例如转账等操作，除了使用 Session 管理用户状态之外，还需要对用户进行重新验证，比如重新输入密码，或者使用短信验证码等方式。

### 3.1.7 浏览器禁用 Cookie

此时无法使用 Cookie 来保存用户信息，只能使用 Session。除此之外，不能再将 Session ID 存放到 Cookie 中，而是使用 URL 重写技术，将 Session ID 作为 URL 的参数进行传递。

### 3.1.8 Cookie 与 Session 选择

- Cookie 只能存储 ASCII 码字符串，而 Session 则可以存取任何类型的数据，因此在考虑数据复杂性时首选 Session；
- Cookie 存储在浏览器中，容易被恶意查看。如果非要将一些隐私数据存在 Cookie 中，可以将 Cookie 值进行加密，然后在服务器进行解密；
- 对于大型网站，如果用户所有的信息都存储在 Session 中，那么开销是非常大的，因此不建议将所有的用户信息都存储到 Session 中。

## 3.2 缓存

### 3.2.1 作用

- 缓解服务器压力；
- 降低客户端获取资源的延迟。

### 3.2.2 实现方法

- 让代理服务器进行缓存；
- 让客户端浏览器进行缓存。

### 3.2.3 Cache-Control

HTTP/1.1 通过 Cache-Control 首部字段来控制缓存。

**（1）禁止进行缓存** 

no-store 指令规定不能对请求或响应的任何数据进行缓存。

```html
Cache-Control: no-store
```

**（2）强制确认缓存** 

no-cache 指令规定缓存服务器需要先向源服务器验证缓存资源的有效性，只有当缓存资源有效才将能使用该缓存对客户端的请求进行响应。

```html
Cache-Control: no-cache
```

**（3）私有缓存和公共缓存** 

private 指令规定了将资源作为私有缓存，只能被单独用户所使用，一般存储在用户浏览器中。

```html
Cache-Control: private
```

public 指令规定了将资源作为公共缓存，可以被多个用户所使用，一般存储在代理服务器中。

```html
Cache-Control: public
```

**（四）缓存过期机制** 

max-age 指令出现在请求报文中，并且缓存资源的缓存时间小于该指令指定的时间，那么就能接受该缓存。

max-age 指令出现在响应报文中，表示缓存资源在缓存服务器中保存的时间。

```html
Cache-Control: max-age=31536000
```

Expires 首部字段也可以用于告知缓存服务器该资源什么时候会过期。在 HTTP/1.1 中，会优先处理 Cache-Control : max-age 指令；而在 HTTP/1.0 中，Cache-Control : max-age 指令会被忽略掉。

```html
Expires: Wed, 04 Jul 2012 08:26:05 GMT
```

### 3.2.4 缓存验证

ETag 它是资源的唯一标识。URL 不能唯一表示资源，例如 `http://www.google.com/` 有中文和英文两个资源，只有 ETag 才能对这两个资源进行唯一标识。

```html
ETag: "82e22293907ce725faf67773957acd12"
```

可以将缓存资源的 ETag 值放入 If-None-Match 首部，服务器收到该请求后，判断缓存资源的 ETag 值和资源的最新 ETag 值是否一致，如果一致则表示缓存资源有效，返回 304 Not Modified。

```html
If-None-Match: "82e22293907ce725faf67773957acd12"
```

Last-Modified 首部字段也可以用于缓存验证，它包含在源服务器发送的响应报文中，指示源服务器对资源的最后修改时间。但是它是一种弱校验器，因为只能精确到一秒，所以它通常作为 ETag 的备用方案。如果响应首部字段里含有这个信息，客户端可以在后续的请求中带上 If-Modified-Since 来验证缓存。服务器只在所请求的资源在给定的日期时间之后对内容进行过修改的情况下才会将资源返回，状态码为 200 OK。如果请求的资源从那时起未经修改，那么返回一个不带有消息主体的 304 Not Modified 响应。

```html
Last-Modified: Wed, 21 Oct 2015 07:28:00 GMT
```

```html
If-Modified-Since: Wed, 21 Oct 2015 07:28:00 GMT
```

## 3.3 Authorization

第三方授权分为两种主流方式： Basic 和 Bearer 。

### 3.3.1 Basic

- 首部字段格式：Authorization: Basic Base64 (username:password)
> 例如：用户名为 passin ，密码为 123456 ，连起来则是 passin:123456 ,再对该字符串进行 Base64 编码，结果为 cGFzc2luOjEyMzQ1Ng==。即，最终添加进请求头的内容是：

```html
Authorization: Basic cGFzc2luOjEyMzQ1Ng==
```

### 3.3.2 Bearer

- 首部字段格式：Authorization: Bearer <bearer token>
- bearer token 的获取方式：通过 OAuth2 的授权流程。

#### 3.3.2.1 OAuth2 授权流程

> 1. 第三方网站向授权方网站申请第三方授权合作，目的是拿到 client id 和 client secret。
> 2. 用户在使用第三方网站时，点击授权（登陆）按钮后，跳转授权方网站，并传入 client id（第三方网站提供）作为用户的身份标识。
> 3. 授权方网站根据 client id ，将第三方网站的信息和第三方网站需要的用户权限展示给用户，并询问用户是否同意授权。
> 4. 用户同意授权后，授权方网站将页面跳转回第三方网站，并传入 Authorization code 作为用户认可的凭证。
> 5. 第三方网站将 Authorization code 发送回自己的服务器。
> 6. 服务器将 Authorization code 和自己的 client secret 一并发送给授权方的服务器，授权方服务器验证通过后，返回 access token。
> 7. 第三方网站（客户端）就可以使用 access token 作为用户授权的令牌，向授权方发送请求来获取用户信息或操作用户账号。

#### 3.3.2.2 OAuth2 微信授权登陆流程

> 1. 第三方 App 向微信开放平台申请第三方授权登陆，拿到 client id 和 client secret。
> 2. 用户在使用第三方 App 时，点击微信登陆按钮后，将通过微信 SDK 跳转至微信，并传入自己的 client id 作为用户的身份标识。
> 3. 微信通过与服务器交互，拿到第三方 App 信息，并限制在微信界面中，将第三方 App 的信息和第三方网站需要的用户权限展示给用户，并询问用户是否同意授权。
> 4. 用户点击 『同意授权』后，微信 App 和 服务区交互将同意授权的信息提交，然后跳转回第三方 App，并传回 Authorization code 作为用户认可的凭证。
> 5. 第三方 App 调用自家服务器的『微信登录』 Api，并传入 Authorization code，并等待服务器的响应。
> 6. 服务器将拿到的 Authorization code 和自己的 client secret 通过调用授权方接口发送给授权方的服务器，微信服务器验证通过后，返回 access token。
> 7. 第三方服务器拿到 access token 作为用户授权的令牌，向微信服务器请求接口来获取用户信息，微信验证同意后，返回用户信息。
> 8. 服务器拿到微信提供的用户信息后，例如该信息在自己的服务器为用户创建一个账号，并将自身服务器的用户 Id 和微信账号的用户 Id 做关联。
> 9. 用户创建完成后，向客户端返回成功的响应以及创建的用户信息。
> 10. 客户端收到响应，利用返回的用户数据进行操作，最终用户登录成功。

#### 3.3.2.3 在自家 App 中使用 Bearer token

简化掉获取 Authorization code 的过程，登录接口请求成功后，直接返回 access token。

#### 3.3.2.4 为什么引入 Authorization code

为了安全，OAuth 并不强制使用 Https，因此需要尽量保证当通信时被窃听时，依旧具有足够的安全性。
- 服务器之间的通信以及服务器自身的数据一般是较为安全的。
- 需要 Authorization code 以及第三方服务器自身才有的 client secret 才能拿到 access token。

#### 3.3.2.5 Refresh token

```
{
        "token_type" : "Bearer",
        "access_token" : "xxxxx",
        "refresh_token" : "xxxxx",
        "expires_time" : "xxxxx",
}
```

用法：accress token 只在一定时间内有效，在它失效后，可调用 refresh_token 接口，并传入 refresh_token 中的参数获取新的 access token。

目的：为了更安全。当 accress token 失窃时，窃取人只有较短时间的去利用它模拟请求接口，而 refresh_token 的值则永远存放于第三方服务器中，不容易失窃。

## 3.4 连接管理

### 3.4.1 短连接与长连接

当浏览器访问一个包含多张图片的 HTML 页面时，除了请求访问 HTML 页面资源，还会请求图片资源，如果每进行一次 HTTP 通信就要断开一次 TCP 连接，连接建立和断开的开销会很大。长连接只需要建立一次 TCP 连接就能进行多次 HTTP 通信。

从 HTTP/1.1 开始默认是长连接的，如果要断开连接，需要由客户端或者服务器端提出断开，添加头部 Connection : close；而在 HTTP/1.1 之前默认是短连接的，如果需要长连接，则添加头部 Connection : Keep-Alive。

长连接的实现方式：每间隔一定时间,使用 TCP 连接发送很短且无意义的消息,让服务器网关不将自己定义为“空闲连接”,从而防止网关关闭连接。

### 3.4.2 管道网络传输

默认情况下，HTTP 请求是按顺序发出的，下一个请求只有在当前请求收到相应之后才会被发出。由于会受到网络延迟和带宽的限制，在下一个请求被发送到服务器之前，可能需要等待很长时间。

管道机制则是允许浏览器同时发出多个请求，而不用等待响应返回，这样可以避免连接延迟，但是服务器还是按照「请求顺序」回应，如果前面的回应特别慢，后面就会有许多请求排队等着。这称为「队头堵塞」。

## 3.5 内容协商

通过内容协商返回最合适的内容，例如根据浏览器的默认语言选择返回中文界面还是英文界面。

### 3.5.1 类型

**（一）服务端驱动型内容协商** 

客户端请求报文设置特定的 HTTP 首部字段，例如 Accept、Accept-Charset、Accept-Encoding、Accept-Language、Content-Languag，服务器根据这些字段返回特定的资源。

它存在以下问题：

- 服务器很难知道客户端浏览器的全部信息；
- 客户端提供的信息相当冗长（HTTP/2 协议的首部压缩机制缓解了这个问题），并且存在隐私风险（HTTP 指纹识别技术）。
- 给定的资源需要返回不同的展现形式，共享缓存的效率会降低，而服务器端的实现会越来越复杂。

**（二）代理驱动型协商** 

服务器返回 300 Multiple Choices 或者 406 Not Acceptable，客户端从中选出最合适的那个资源。

### 3.5.2 Vary

```html
Vary: Accept-Language
```

在使用内容协商的情况下，只有当缓存服务器中的缓存满足内容协商条件时，才能使用该缓存，否则应该向源服务器请求该资源。

例如，一个客户端发送了一个包含 Accept-Language 首部字段的请求之后，源服务器返回的响应包含 `Vary: Accept-Language` 内容，缓存服务器对这个响应进行缓存之后，在客户端下一次访问同一个 URL 资源，并且 Accept-Language 与缓存中的对应的值相同时才会返回该缓存。

## 3.6 内容编码

内容编码将实体主体进行压缩，从而减少传输的数据量。常用的内容编码有：gzip、compress、deflate、identity。

浏览器发送 Accept-Encoding 首部，其中包含有它所支持的压缩算法，以及各自的优先级，服务器则从中选择一种，使用该算法对响应的消息主体进行压缩，并且发送 Content-Encoding 首部来告知浏览器它选择了哪一种算法。由于该内容协商过程是基于编码类型来选择资源的展现形式的，在响应中，Vary 首部中至少要包含 Content-Encoding，这样的话，缓存服务器就可以对资源的不同展现形式进行缓存。

## 3.7 范围请求

如果网络出现中断，服务器只发送了一部分数据，范围请求可以使得客户端只请求服务器未发送的那部分数据，从而避免服务器重新发送所有数据。

### 3.7.1 Range

在请求报文中添加 Range 首部字段指定请求的范围。

```html
GET /z4d4kWk.jpg HTTP/1.1
Host: i.imgur.com
Range: bytes=0-1023
```

请求成功的话服务器返回的响应包含 206 Partial Content 状态码。

```html
HTTP/1.1 206 Partial Content
Content-Range: bytes 0-1023/146515
Content-Length: 1024
...
(binary content)
```

### 3.7.2 Accept-Ranges

响应首部字段 Accept-Ranges 用于告知客户端是否能处理范围请求，可以处理使用 bytes，否则使用 none。

```html
Accept-Ranges: bytes
```

### 3.7.3 响应状态码

- 在请求成功的情况下，服务器会返回 206 Partial Content 状态码。
- 在请求的范围越界的情况下，服务器会返回 416 Requested Range Not Satisfiable 状态码。
- 在不支持范围请求的情况下，服务器会返回 200 OK 状态码。

## 3.8 分块传输编码

分块传输编码（Chunked Transfer EnCoding） 可以把一个 Http 连接的数据分割成多块，边传输边接收。

作用：

- 服务器向客户端发送数据：让浏览器逐步显示页面，尽早给出响应，减少用户等待。
- 客户端向服务器发送数据：请求体的 Body 长度无法确定，Content-Length 不能使用。

Body 格式：

```
<length1>
<data1>
<length2>
<data2>
……
0

(最后传输 0 表示内容结束)
```

## 3.9 多部分对象集合

一份报文主体内可含有多种类型的实体同时发送，每个部分之间用 boundary 字段定义的分隔符进行分隔，每个部分都可以有首部字段。

例如，上传多个表单时可以使用如下方式：

```html
Content-Type: multipart/form-data; boundary=AaB03x

--AaB03x
Content-Disposition: form-data; name="submit-name"

--AaB03x
Content-Disposition: form-data; name="files"; filename="file1.txt"
Content-Type: text/plain

... contents of file1.txt ...
--AaB03x--
```

## 3.10 WebSocket

WebSocket 是基于 TCP 实现的全双工应用层协议。特殊在于，WebSocket 在建立连接时，需要借用 HTTP 的 101 switch protocol 来达到协议转换。在建立连接后，再往后发送数据就是通过 TCP 协议了，也就是说 WebSocket 只是使用 Http 协议来完成握手操作。

### 3.10.1 连接过程

**（1）请求报文**

```
Host: server.example.com
Upgrade: websocket
Connection: Upgrade
Sec-WebSocket-Key: dGhlIHNhbXBsZSBub25jZQ==
Origin: http://example.com
Sec-WebSocket-Protocol: chat, superchat
Sec-WebSocket-Version: 13
```

简单描述一下各个请求头的含义：

- Upgrade：HTTP1.1 开始表示要升级（转换）到某个协议（如果服务器支持的话）。

- Connection：内容为 Upgrade 表示要进行升级协议。

- Sec-WebSocket-Key：用来发送给服务器过滤非预期的请求 (比如手动填写 header 中的一些信息，但本身不想升级到 WebSocket。这时候，由于 Sec-WebSocket-Key 和一些相关项被禁止手动设置，所以可以过滤掉出现非预期的情况)。

- Origin：防止跨站攻击，浏览器一般会使用这个来标识原始域。

- Sec-WebSocket-Protocol：客户端支持的子协议列表。

- Sec-WebSocket-Version：客户端支持的 WebSocket 协议的版本。

**（2）响应报文**

```
HTTP/1.1 101 Switching Protocols
Upgrade: websocket
Connection: Upgrade
Sec-WebSocket-Accept: s3pPLMBiTxaQ9kYGzzhZRbK+xOo=
Sec-WebSocket-Protocol: chat
```

### 3.10.2 数据帧格式

遵循 RFC 规范实现的 WebSocket，协议自带包长，不会有产生粘包/拆包问题，因此，可以认为 WebSocket 的功能之一就是专门处理 TCP 粘包问题，并在 TCP 的基础上，封装了一些帧实现，方便开发者使用。

```
  0                   1                   2                   3
  0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
 +-+-+-+-+-------+-+-------------+-------------------------------+
 |F|R|R|R| opcode|M| Payload len |    Extended payload length    |
 |I|S|S|S|  (4)  |A|     (7)     |             (16/64)           |
 |N|V|V|V|       |S|             |   (if payload len==126/127)   |
 | |1|2|3|       |K|             |                               |
 +-+-+-+-+-------+-+-------------+ - - - - - - - - - - - - - - - +
 |     Extended payload length continued, if payload len == 127  |
 + - - - - - - - - - - - - - - - +-------------------------------+
 |                               |Masking-key, if MASK set to 1  |
 +-------------------------------+-------------------------------+
 | Masking-key (continued)       |          Payload Data         |
 +-------------------------------- - - - - - - - - - - - - - - - +
 :                     Payload Data continued ...                :
 + - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - +
 |                     Payload Data continued ...                |
 +---------------------------------------------------------------+
```

- FIN：（finish）1 bit。

  如果是 1，表示这是消息的最后一个分片（fragment）；如果是 0，表示不是最后一个分片。
  
- RSV1, RSV2, RSV3：各占 1 bit。

  若不采用 WebSocket 扩展这里必须为 0。当客户端、服务端协商采用 WebSocket 扩展时，这三个标志位可以非 0，且值的含义由扩展进行定义。如果出现非零的值，且没有采用 WebSocket 扩展，则连接出错。

- Opcode: 4 bit。

  操作码。Opcode 的值决定了应该如何解析后续的数据载荷（data payload），可以理解为 Http 的响应体。如果收到一个未知的操作码，接收端点应该断开连接（fail the connection）。可选的操作代码如下：

```
%x0：表示一个延续帧。当 Opcode 为 0 时，表示本次数据传输采用了数据分片，当前收到的数据帧为其中一个数据分片；
%x1：表示这是一个文本帧（frame）；
%x2：表示这是一个二进制帧（frame）；
%x3-7：保留的操作代码，用于后续定义的非控制帧，（一般协议中都会预留出一些码用于扩展）；
%x8：表示连接断开/关闭；
%x9：表示这是一个 ping 操作；
%xA：表示这是一个 pong 操作；
%xB-F：保留的操作代码，用于后续定义的控制帧（一般协议中都会预留出一些码用于扩展）。
```
- Mask: 1 bit。

  表示是否要对数据载荷进行掩码操作。从客户端向服务端发送数据时，需要对数据进行掩码操作，Mask 需要为 1，masking-key（掩码键）字段存在值；从服务端向客户端发送数据时，不需要对数据进行掩码操作，Mask 需要为 0。如果服务端接收到的数据没有进行过掩码操作，服务端需要断开连接。

- Payload length：数据载荷的长度，单位是 bit，代表了用多少 bit 来表示数据的长度。当数据的长度在 0-125 之间时，Payload length 为 7；当数据的长度在 126-2^16-1 时，Payload length 为 7+16；当数据的长度在 2^16-1~2^64-1 时，Payload length 为 7+64。

  该算法的实现：7 bit 能表示的最大数值为 127，但只用它来表示 125 内（包含）的数据长度，若为 126 则表示需要额外 2 个字节的长度，若为 127 则需要额外 8 个字节的长度。这种定义负载长度方式是一种网络协议中常用的方法，可以实现灵活的扩展数据长度。

- Masking-key：0 或 4 字节（32 位）

  所有从客户端传送到服务端的数据帧，数据载荷都进行了掩码操作，Mask 为 1，且携带了 4 字节的 Masking-key。如果 Mask 为 0，则没有 Masking-key。

- Payload data：(载荷数据 x+y 字节)

  载荷数据：包括了扩展数据、应用数据。其中，扩展数据 x 字节，应用数据 y 字节。载荷数据的长度，不包括 mask key 的长度。

- Extension data（扩展数据 x 字节）：

  如果没有协商使用扩展的话，扩展数据数据为 0 字节。所有的扩展都必须声明扩展数据的长度，或者可以如何计算出扩展数据的长度。此外，扩展如何使用必须在握手阶段就协商好。如果扩展数据存在，那么载荷数据长度必须将扩展数据的长度包含在内。

- Application data（应用数据 y 字节）：

  在扩展数据之后（如果存在扩展数据），应用数据占据了数据帧剩余的位置。即应用数据的长度等于载荷数据长度减去扩展数据长度。

# 四、HTTPS

HTTP 有以下安全性问题：

- 使用明文进行通信，内容可能会被窃听；
- 不验证通信方的身份，通信方的身份有可能遭遇伪装；
- 无法证明报文的完整性，报文有可能遭篡改。

HTTPS 并不是新协议，而是让 HTTP 先和 SSL（Secure Sockets Layer）通信，再由 SSL 和 TCP 通信。也就是说 HTTPS 使用了隧道进行通信。

通过使用 SSL，HTTPS 具有了加密（防窃听）、认证（防伪装）和完整性保护（防篡改）的特性。

HTTP 的默认端口号是 80，HTTPS 的默认端口号是 443。

## 4.1 加密

加密的目的，是不希望第三者看到当前两个通讯用户的通讯内容。

### 4.1.1 对称密钥加密

对称密钥加密（Symmetric-Key Encryption），加密和解密使用同一密钥。

- 优点：运算速度快；
- 缺点：无法安全地将密钥传输给通信方。

### 4.1.2 非对称密钥加密

非对称密钥加密，又称公开密钥加密（Public-Key Encryption），加密和解密使用不同的密钥，公钥可被都可以获得，并且私钥和公钥是互相可解的。

以下用 A（客户端）和 B（服务器）描述非对称密钥加密的应用。

1. B 将公钥发送给 A；
2. A 用 B 给他的公钥加密这段消息，然后传给 B；
3. B 收到消息后使用私有密钥解密（只有接收方有私钥才能解密，从而达到保密的目的）；
4. 若 B 想向 A 回复消息，则 B 用自己的私钥加密信息，发送给 A；
5. A 收到消息后，用公钥解密信息。

- 优点：可以更安全地将公开密钥传输给通信发送方。
- 缺点：运算速度慢。

非对称密钥加密除了用来加密，还可以用来进行签名。此处以 B 给 A 回信为例说明这个过程：

1. B 对信息使用 hash 算法，生成信件摘要；
2. B 再使用其私有密钥进行加密，就生成了数字签名(signature)；
3. B 将这个签名附在要回复的信息中（例如请求头），一起发给 A；
4. A 使用公钥对数字签名进行解密，并对信息使用同样的 hash 算法，将得到 hash 值与这个签名对比是否一致来判断信息是否被篡改。

不怀好意的人也可以修改信息内容的同时也修改 hash 值，从而让它们可以相匹配，为了防止这种情况，hash 值一般都会加密后(也就是数字签名)再和信息一起发送。

## 4.2 证书（认证）

由于客户端无法确定给它公钥的就是真正的服务器，此时则需要通过使用 **证书** 来对通信方进行认证。

数字证书认证机构（CA，Certificate Authority）是客户端与服务器双方都可信赖的第三方机构。
CA 用自己的私钥对用户的身份信息(包含用户的公钥)进行数字签名，该签名和用户的身份信息一起就形成了证书。

### 4.2.1 证书包含的信息

- 签发机构的公钥：用于数字签名解密。
- 证书有效期。证书过了有效期限，证书就会作废。
- 证书的所有者（一般是某个人或者某个公司名称、机构的名称、公司网站的网址等）。
- 证书签名算法：证书签名所使用的加密算法。签发机构的公钥，根据这个算法对数字签名进行解密，得到摘要（hash 值）。
- 指纹算法：某种 hash 算法。
- 证书签名：用于保证证书的完整性，确保证书没有被修改过。其原理就是在发布证书时，发布者根据指纹算法计算证书信息得到指纹（hash 值）再使用私钥加密得到数字签名，并和证书放在一起。使用者在打开证书时，使用公钥对证书签名解密得到指纹，并使用指纹算法计算证书信息得到新的指纹，再进行对比是否一致，若一致就说明证书没有被修改过。
- 签发机构的签发机构的......(上面包含的信息)：由于签发机构可以通过另外一个更高级别的签发机构对该证书机构的公钥颁发一个证书（一般是不超过 3 级），这样形成了一个公钥证书的嵌套循环。

### 4.2.2 证书的验证过程 

- 对比证书吊销列表，检查 SSL 证书是否被证书颁发机构吊销。
- 检查 SSL 证书是否过期。
- 检查部署此 SSL 证书的网站的域名是否与证书中的域名一致。
- 检查 SSL 证书是否是由系统 **受信任的根证书颁发机构** 颁发。
- 利用签发机构的公钥对证书签名进行验证，如果验证过后所得的信息和证书签名一致，则验证通过。依次逐级对签发机构进行验证，直至本地所信任的根签发机构验证通过。

## 4.3 完整性保护

SSL 提供报文摘要功能来进行完整性保护。

HTTP 也提供了 MD5 报文摘要功能，但不是安全的。例如报文内容被篡改之后，同时重新计算 MD5 的值，通信接收方无法意识到发生了篡改。

HTTPS 的报文摘要功能之所以安全，是因为它结合了加密和认证这两个操作。因为加密之后的报文，遭到篡改之后，也很难重新计算为一致的报文摘要，因为无法轻易获取明文。

## 4.4 HTTPS 的缺点

- 因为需要进行加密解密等过程，因此速度会更慢。
- 需要支付证书授权的费用。

## 4.5 HTTPS 连接建立过程

  1. 客户端向服务器发送一条消息 **Client Hello**，Client Hello 包含的内容：客户端所能接受的（多个）SSL/TLS 版本、加密算法（对称加密算法和非对称加密算法）、hash 算法、一个客户端随机数、Server Name（表明是客户端与服务器下哪一个具体的子服务器建立链接）。
  2. 服务器接收到 Client Hello 后，将客户端随机数保存下来，并从中确定将要使用的 SSL/TLS 版本、加密算法、hash 算法。
  3. 服务器向客户端发送一条消息 **Server Hello**，消息中包含一个随机数以及确定使用的 SSL/TLS 版本、加密算法、hash 算法，客户端也将此随机数保存下来，自此客户端和服务器皆拥有一个客户端随机数和一个服务器随机数（用于计算 Pre-master Secret）。
  4. 服务器再向客户端发送证书以及选取的非对称加密算法的公钥（放置在证书中），客户端收到证书后进行验证。验证通过后，建立信任。
  5. 客户端通过自己的信息算出一个 Pre-master Secret，并使用服务器传过来的公钥进行加密，再发送给服务器（两端皆存）。
  6. 两端利用 Pre-master Secret、客户端随机数、服务器随机数使用一个固定算法算出一个名为 Master Secret 的数据。再解析 Master Secret 得到真正进行通讯时用的客户端加密密钥、服务端加密密钥，以及用来验证身份的客户端 MAC Secret、服务器 MAC Secret。
  7. 客户端向服务器发送一条通知：“我”将使用加密通信了。
  8. 客户端再向服务器发送一条消息： **Finished**。该消息的内容为：将所有的握手信息和客户端加密密钥进行 [HMAC](https://baike.baidu.com/item/hmac/7307543?fr=aladdin) 运算的结果。
  9. 服务器向客户端发送一条消息：“我”将使用加密通信了。
  10. 服务器再向客户端发送一条消息： **Finished**。该消息的内容为：服务器也进行同样的 HMAC 运算后与客户端对比，一致则认为客户端是合法的。若合法，服务器将所有的握手信息以及客户端的 HMAC 的结果和服务器加密密钥进行 HMAC 运算后发给客户端。
  11. 客户端接收到服务端的 **Finished** 后，同样以相同算法进行对比验证以确定服务端以及密钥是否是合法（正确）的。若验证通过，则开始进行 HTTPS 请求。

# 五、GET 和 POST 的区别

## 5.1 作用

GET 用于获取资源，而 POST 用于传输实体主体。

## 5.2 参数

GET 和 POST 的请求都能使用额外的参数，但是 GET 的参数是拼接在 URL 中，而 POST 的参数存储在请求体中。

```
GET /test/demo_form.asp?name1=value1&name2=value2 HTTP/1.1
```

```
POST /test/demo_form.asp HTTP/1.1
Host: w3schools.com
name1=value1&name2=value2
```

不能因为 POST 参数存储在实体主体中就认为它的安全性更高，因为照样可以通过一些抓包工具（Fiddler）查看。

因为 URL 只支持 ASCII 码，因此 GET 的参数中如果存在中文等字符就需要先进行编码，例如`中文`会转换为`%E4%B8%AD%E6%96%87`，而空格会转换为`%20`。POST 支持标准字符集。

## 5.3 安全

这里所说的安全是相对的，主要指数据不会被篡改。

安全的 HTTP 方法不会改变服务器状态，也就是说它只是可读的。因此 GET 方法是安全的，而 POST 是不安全的，因为 POST 的目的是传送实体主体内容，这个内容可能是用户上传的表单数据，上传成功之后，服务器可能把这个数据存储到数据库中，因此状态也就发生了改变。

安全的方法除了 GET 之外还有：HEAD、OPTIONS。

不安全的方法除了 POST 之外还有 PUT、DELETE。

## 5.4 幂等性

幂等的 HTTP 方法，同样的请求被执行一次与连续执行多次的效果是一样的，服务器的状态也是一样的。换句话说就是，幂等方法不应该具有副作用（统计用途除外）。在正确实现的条件下，GET，HEAD，PUT 和 DELETE 等方法都是幂等的，而 POST 方法不是。所有的安全方法也都是幂等的。

GET /pageX HTTP/1.1 是幂等的。连续调用多次，客户端接收到的结果都是一样的：

```
GET /pageX HTTP/1.1
GET /pageX HTTP/1.1
GET /pageX HTTP/1.1
GET /pageX HTTP/1.1
```

POST /add_row HTTP/1.1 不是幂等的。如果调用多次，就会增加多行记录：

```
POST /add_row HTTP/1.1   -> Adds a 1nd row
POST /add_row HTTP/1.1   -> Adds a 2nd row
POST /add_row HTTP/1.1   -> Adds a 3rd row
```

DELETE /idX/delete HTTP/1.1 是幂等的，即便不同的请求接收到的状态码不一样：

```
DELETE /idX/delete HTTP/1.1   -> Returns 200 if idX exists
DELETE /idX/delete HTTP/1.1   -> Returns 404 as it just got deleted
DELETE /idX/delete HTTP/1.1   -> Returns 404
```

## 5.5 可缓存

如果要对响应进行缓存，需要满足以下条件：

- 请求报文的 HTTP 方法本身是可缓存的，包括 GET 和 HEAD，但是 PUT 和 DELETE 不可缓存，POST 在多数情况下不可缓存的。
- 响应报文的状态码是可缓存的，包括：200, 203, 204, 206, 300, 301, 404, 405, 410, 414, and 501。
- 响应报文的 Cache-Control 首部字段没有指定则不缓存。

# 六、HTTP/1.1、HTTP/2、HTTP/3

<div align="center"> <img src="../pictures//HTTP协议的区别.webp"/> </div>

## 6.1 HTTP/1.1

HTTP/1.1 相比 HTTP/1.0 性能上的改进：

- 使用 TCP 长连接的方式改善了 HTTP/1.0 短连接造成的性能开销。

- 支持「管道网络传输」，只要第一个请求发出去了，不必等其回来，就可以发第二个请求出去，可以减少整体的响应时间。

但 HTTP/1.1 还是有性能瓶颈：

- 请求 / 响应头部（Header）未经压缩就发送，首部信息越多延迟越大。只能压缩 Body 的部分；

- 发送冗长的首部。每次互相发送相同的首部造成的浪费较多；

- 服务器是按请求的顺序响应的，如果服务器响应慢，会招致客户端一直请求不到数据，也就是队头阻塞；

- 没有请求优先级控制；

- 请求只能从客户端开始，服务器只能被动响应。

## 6.2 HTTP/2

HTTP/2 相比 HTTP/1.1 性能上的改进：

**（1）头部压缩**

HTTP/2 会压缩头（Header）如果你同时发出多个请求，他们的头是一样的或是相似的，那么，协议会帮你消除重复的分。

这就是「HPACK」算法：在客户端和服务器同时维护一张头信息表，所有字段都会存入这个表，生成一个索引号，以后就不发送同样字段了，只发送索引号，这样就提高速度了。

**（2）二进制格式**

HTTP/2 不再像 HTTP/1.1 里的纯文本形式的报文，而是全面采用了二进制格式，头信息和数据体都是二进制，并且统称为帧（frame）：头信息帧和数据帧。

这样虽然对人不友好，但是对计算机非常友好，计算机在收到报文后，无需再将明文的报文转成二进制，而是直接解析二进制报文，这增加了数据传输的效率。

**（3）数据流**
 
HTTP/2 的数据包不是按顺序发送的，同一个连接里面连续的数据包，可能属于不同的响应。

每个请求或回应的所有数据包，称为一个数据流（Stream）。每个数据流都标记着一个独一无二的编号，用于指出它属于哪个响应，其中规定客户端发出的数据流编号为奇数，服务器发出的数据流编号为偶数。

客户端还可以指定数据流的优先级。优先级高的请求，服务器就先响应该请求。

**（4）多路复用**

HTTP/2 移除了 HTTP/1.1 中的串行请求，支持在一个连接中并发多个请求或回应，不需要排队等待，也就不会再出现「队头阻塞」问题，降低了延迟，大幅度提高了连接的利用率。

举例来说，在一个 TCP 连接里，服务器收到了客户端 A 和 B 的两个请求，如果发现 A 处理过程非常耗时，于是就回应 A 请求已经处理好的部分，接着回应 B 请求，完成后，再回应 A 请求剩下的部分。

**（5）服务器推送**

HTTP/2 还在一定程度上改善了传统的「请求 - 应答」工作模式，服务不再是被动地响应，也可以主动向客户端发送消息。

例如：在浏览器刚请求 HTML 的时候，就提前把可能会用到的 JS、CSS 文件等静态资源主动发给客户端，减少延时的等待，也就是服务器推送（Server Push，也叫 Cache Push）。

## 6.3 HTTP/3

HTTP/3 相比 HTTP/2 性能上的改进：

HTTP/2 由于多个 HTTP 请求在复用一个 TCP 连接，下层的 TCP 协议是不知道有多少个 HTTP 请求的，因此一旦发生了丢包现象，就会触发 TCP 的重传机制，这就导致在一个 TCP 连接中的所有的 HTTP 请求都必须等待这个丢了的包被重传回来才能继续进行发送，**所以 HTTP/3 把 HTTP 下层的 TCP 协议改成了 UDP**。

首先 UDP 传输协议是是不可靠的，但基于 UDP 的 QUIC 协议 可以实现类似 TCP 的可靠性传输。

- QUIC 有自己的一套机制可以保证传输的可靠性的。当某个流发生丢包时，只会阻塞这个流，其他流不会受到影响。

- TL3 升级到 1.3 版本，头部压缩算法也升级成了「QPack」。

- HTTPS 要建立一个连接，要花费 6 次交互，先是建立三次握手，然后是 TLS/1.3 的三次握手。QUIC 直接把以往的 TCP 和 TLS/1.3 的 6 次交互合并成了 3 次，减少了交互次数。

由于 QUIC 是新协议，对于很多网络设备都不支持，因此 HTTP/3 的普及进度比较缓慢。

# 参考资料

- 上野宣. 图解 HTTP[M]. 人民邮电出版社, 2014.
- [HTTP - CS-Notes](https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/HTTP.md)
- [浅谈 HTTP 中 Get 与 Post 的区别 ](https://www.cnblogs.com/hyddd/archive/2009/03/31/1426026.html)
- [WebSocket 和 Socket](https://www.cnblogs.com/-flq/p/9073422.html)
- [图解网络](https://mp.weixin.qq.com/mp/appmsgalbum?action=getalbum&album_id=1337204681134751744&__biz=MzUxODAzNDg4NQ==#wechat_redirect)

