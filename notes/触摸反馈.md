
# 触摸反馈

## MotionEvent

### 单点触控

事件类型：

- ACTION_DOWN： 手指 **初次接触到屏幕时** 触发。
- ACTION_MOVE：手指在 **屏幕上滑动** 时触发，会多次触发。
- ACTION_UP：手指 **离开屏幕** 时触发。
- ACTION_CANCEL：事件 **被上层拦截** 时触发
- ACTION_OUTSIDE：手指 **不在控件区域** 时触发（例如 Dialog）。

方法：

- getAction()：获取事件类型。
- getX()：获得触摸点在当前 View 的 X 轴坐标。
- getY()：获得触摸点在当前 View 的 Y 轴坐标。
- getRawX()：获得触摸点在整个屏幕的 X 轴坐标。
- getRawY()：获得触摸点在整个屏幕的 Y 轴坐标。


### 多点触控

事件类型：

- ACTION_DOWN： **第一个** 手指 **接触到屏幕时** 触发。
- ACTION_MOVE：手指在 **屏幕上滑动** 时触发，会多次触发。
- ACTION_UP：**最后一个** 手指 **离开屏幕** 时触发。
- ACTION_POINTER_DOWN：有非主要的手指按下(**即按下之前已经有手指在屏幕上**)。
- ACTION_POINTER_UP：有非主要的手指抬起(即抬起之后仍然有手指在屏幕上)。

方法：

- getActionMasked()：与 getAction() 类似，多点触控必须使用这个方法获取事件类型。
- getActionIndex()：获取该事件是哪个指针(手指)产生的。
- getPointerCount()：获取在屏幕上手指的个数。
- getPointerId(int pointerIndex)：获取一个指针(手指)的唯一标识符ID，在手指按下和抬起之间ID始终不变。
- findPointerIndex(int pointerId)：通过PointerId获取到当前状态下PointIndex，之后通过PointIndex获取其他内容。
- getX(int pointerIndex)：获取某一个指针(手指)的X坐标
- getY(int pointerIndex)：获取某一个指针(手指)的Y坐标

多点触控将index属性和事件类型合并以一个int作为标识，用最低8位(0x000000ff)表示事件类型，再往前的8位(0x0000ff00)表示事件编号。

追踪事件流，请认准 PointId，ActionIndex 只有在手指按下(down)和抬起(up)时是有用的。

PointId 在手指按下时产生，手指抬起或者事件被取消后消失，可以在手指按下或抬起时，通过 getPointerId(int pointerIndex) 获得，pointerIndex也就是ActionIndex。


## 事件分发机制

事件分发的简单总结：

1. 重写 onTouchEvent()，在里面写上你的触摸反馈算法，并返回 true（是否消费事件取决于 ACTION_DOWN 事件或 ACTION_POINTER_DOWN 时是否返回 true），如果返回 false，则在这组触摸事件中永不接管当前事件流。
2. 如果是会发生触摸冲突的 ViewGroup，还需要重写 onInterceptTouchEvent()，在事件流开始时返回 false，并在确认接管事件流时返回一次 true，以实现对事件的拦截和接管，并在接管之后对它的子 View 发送一个额外的取消事件 CANCEL。
3. ViewGroup 会从最上层的 View 开始不断向下层 View（ViewGroup） 询问是否接管事件流。
4. 当子 View 临时需要组织父 View 拦截事件流时，可以调用父 View 的 requestDisallowInterceptTouchEvent() ，通知父 View 在当前事件流中不再尝试通过 onInterceptTouchEvent() 来拦截。
5. onTouchEvent() 和 onInterceptTouchEvent() 都是在 dispatchTouchEvent() 中调用，一个事件分发的过程实质上就是从根 View 递归调用 dispatchTouchEvent() 的过程。

该章节事件分发的源码分析基于Android SDK 28。

### View 的事件分发机制 dispatchTouchEvent()

当 View 的 dispatchTouchEvent() 返回false时，表示不消费该事件流。

以下代码非所有源代码，只保留了主干源码。

```java
public boolean dispatchTouchEvent(MotionEvent event) {

    // 标记是否消费事件。
    boolean result = false;

    if (onFilterTouchEventForSecurity(event)) {
        // 如果该 View 处于可用，并且滑动了滚动条。
        if ((mViewFlags & ENABLED_MASK) == ENABLED && handleScrollBarDragging(event)) {
            result = true;
        }
        // 是否设置了 OnTouchListener，如果设置了调用 mOnTouchListener.onTouch(this, event),
        // 该方法可以选择返回 false，不消费事件。
        ListenerInfo li = mListenerInfo;
        if (li != null && li.mOnTouchListener != null
                && (mViewFlags & ENABLED_MASK) == ENABLED
                && li.mOnTouchListener.onTouch(this, event)) {
            result = true;
        }

        // 如果事件没被消费，调用 View 的 onTouchEvent(event)。
        if (!result && onTouchEvent(event)) {
            result = true;
        }
    }

    return result;
}
```

#### View onTouchEvent()
 
 ```java
public boolean onTouchEvent(MotionEvent event) {
    final float x = event.getX();
    final float y = event.getY();
    final int viewFlags = mViewFlags;
    final int action = event.getAction();

    // 当前 View 是否可点击。
    // 判断标准为只要 CLICKABLE、LONG_CLICKABLE、CONTEXT_CLICKABLE（鼠标等）有一个被标记成 true。
    final boolean clickable = ((viewFlags & CLICKABLE) == CLICKABLE
            || (viewFlags & LONG_CLICKABLE) == LONG_CLICKABLE)
            || (viewFlags & CONTEXT_CLICKABLE) == CONTEXT_CLICKABLE;

    // 如果 View 被标记为不可用。
    if ((viewFlags & ENABLED_MASK) == DISABLED) {
        // View 不可用却 clickable 又为true时，直接消费事件，不再向下层 View 传递。
        return clickable;
    }

    // 设置代理 View，将当前 View 的部分区域的事件处理按照代理 View 的逻辑（onTouchEvent()）去执行。
    if (mTouchDelegate != null) {
        if (mTouchDelegate.onTouchEvent(event)) {
            return true;
        }
    }

    // 如果可点击或使用了 TOOLTIP（长按当前 View时会在长按的坐标上面提示一段信息，xml 的 API 为 tooltipText）。
    // 只要走进该方法，返回值都为true，也就是说 clickable 为true或者使用了TOOLTIP都代表消费该事件。
    if (clickable || (viewFlags & TOOLTIP) == TOOLTIP) {
        switch (action) {
            case MotionEvent.ACTION_DOWN:
                // 如果该事件通过屏触摸屏幕得到，便标志为手指按下。
                if (event.getSource() == InputDevice.SOURCE_TOUCHSCREEN) {
                    mPrivateFlags3 |= PFLAG3_FINGER_DOWN;
                }
                mHasPerformedLongPress = false;

                // 如果不可点击，还走到了这里，说明使用了 TOOLTIP。
                if (!clickable) {
                    // 看到此，可先跳转到checkForLongClick()的代码分析。
                    // 该方法主要处理OnLongClickListener、 Menu 和 TOOLTIP。 
                    // 此时调用该方法也是为了处理 TOOLTIP。
                    checkForLongClick(0, x, y);
                    break;
                }

                // 是否存在一个父 View 是可滑动的控件。
                boolean isInScrollingContainer = isInScrollingContainer();


                if (isInScrollingContainer) {
                    // 预按下状态，经过 100 毫秒后，才设置按下状态，并监听长按事件。
                    mPrivateFlags |= PFLAG_PREPRESSED;
                    if (mPendingCheckForTap == null) {
                        mPendingCheckForTap = new CheckForTap();
                    }
                    mPendingCheckForTap.x = event.getX();
                    mPendingCheckForTap.y = event.getY();
                    postDelayed(mPendingCheckForTap, ViewConfiguration.getTapTimeout());
                } else {
                    // 如果不是在滑动控件，直接设置按下状态，并监听长按事件。
                    // setPressed()第一个参数的作用是是否产生按下的drawable（水波纹）。
                    setPressed(true, x, y);
                    checkForLongClick(0, x, y);
                }
                break;

            case MotionEvent.ACTION_MOVE:
                // 更新 drawable 的位置。
                if (clickable) {
                    drawableHotspotChanged(x, y);
                }

                // pointInView()：移动的坐标是否超出 View 的绘制范围。
                // mTouchSlop：在超出 View 的绘制范围 mTouchSlop 个像素内依旧算移动该 View。
                // 当移除当前 View的范围后，会取消一系列事件。
                if (!pointInView(x, y, mTouchSlop)) {

                    // 取消预按下事件Runnale。
                    removeTapCallback();
                    // 取消长按事件Runnale。
                    removeLongPressCallback();
                    // 取消按下的 drawable 效果。
                    if ((mPrivateFlags & PFLAG_PRESSED) != 0) {
                        setPressed(false);
                    }
                    // 清理 TOOLTIP 标记。
                    mPrivateFlags3 &= ~PFLAG3_FINGER_DOWN;
                }
                break;

            case MotionEvent.ACTION_UP:
                // 清理 TOOLTIP 标记。
                mPrivateFlags3 &= ~PFLAG3_FINGER_DOWN;

                // 如果使用了 TOOLTIP，则对 TOOLTIP 进行相关资源回收（UI 方面表现为 1500ms后显示的字体消失）。
                if ((viewFlags & TOOLTIP) == TOOLTIP) {
                    handleTooltipUp();
                }
                // 如果不可点击，回收资源，不再往下执行。
                if (!clickable) {
                    // 这里主要移除 TOOLTIP 相关的 Runnale。
                    removeTapCallback();
                    removeLongPressCallback();
                    mInContextButtonPress = false;
                    mHasPerformedLongPress = false;
                    mIgnoreNextUpEvent = false;
                    break;
                }

                // prepressed 为 true 表示用户处于预按下状态，就抬起了手。
                boolean prepressed = (mPrivateFlags & PFLAG_PREPRESSED) != 0;
                if ((mPrivateFlags & PFLAG_PRESSED) != 0 || prepressed) {
                    boolean focusTaken = false;
                    // 如果当前 View 没有获取到焦点。
                    if (isFocusable() && isFocusableInTouchMode() && !isFocused()) {
                        // 尝试获取焦点。
                        focusTaken = requestFocus();
                    }

                    // 设置为按下状态，显示 drawable 效果，让用户知道他曾经按下过。
                    if (prepressed) {
                        setPressed(true, x, y);
                    }

                    // mHasPerformedLongPress 为 true 表示消费了长按事件，则不再响应点击事件。
                    if (!mHasPerformedLongPress && !mIgnoreNextUpEvent) {
                        // 长按事件默认会在 1500 ms后尝试响应，可能也设置了长按事件和点击事件，
                        // 在 1500 ms 内抬起了手，响应点击事件，并移除长按事件的 Runnale。
                        removeLongPressCallback();

                        // 如果获取到了焦点，则不再响应点击事件。
                        // 例如点击 EditText 的输入框，优先获取焦点后，便不再响应点击事件。
                        if (!focusTaken) {
                            if (mPerformClick == null) {
                                mPerformClick = new PerformClick();
                            }
                            if (!post(mPerformClick)) {
                                performClickInternal();
                            }
                        }
                    }

                    if (mUnsetPressedState == null) {
                        mUnsetPressedState = new UnsetPressedState();
                    }
                    if (prepressed) {
                        // 处于预按下的状态便抬手，便在 64 ms毫秒后，设置为未按下状态，关闭 drawable 效果。
                        postDelayed(mUnsetPressedState,
                                ViewConfiguration.getPressedStateDuration());
                    } else if (!post(mUnsetPressedState)) {
                        // 否则直接关闭 drawable 效果。
                        mUnsetPressedState.run();
                    }

                    // 移除 TapCallback,当用户设置了长按监听，并不消费长按事件时还使用了 TOOLTIP，
                    // 便可能触发 TOOLTIP 显示的任务。
                    removeTapCallback();
                }
                mIgnoreNextUpEvent = false;
                break;

            case MotionEvent.ACTION_CANCEL:
                // Drawable恢复未按压状态、重置各类标记、移除各类Runnale。
                if (clickable) {
                    setPressed(false);
                }
                removeTapCallback();
                removeLongPressCallback();
                mInContextButtonPress = false;
                mHasPerformedLongPress = false;
                mIgnoreNextUpEvent = false;
                mPrivateFlags3 &= ~PFLAG3_FINGER_DOWN;
                break;
        }

        return true;
    }

    return false;
}
```

##### checkForLongClick(0, x, y)

```java
private void checkForLongClick(int delayOffset, float x, float y) {

    if ((mViewFlags & LONG_CLICKABLE) == LONG_CLICKABLE || (mViewFlags & TOOLTIP) == TOOLTIP) {
        mHasPerformedLongPress = false;

        if (mPendingCheckForLongPress == null) {
            // CheckForLongPress 为一个Runnable。
            mPendingCheckForLongPress = new CheckForLongPress();
        }
        mPendingCheckForLongPress.setAnchor(x, y);
        mPendingCheckForLongPress.rememberWindowAttachCount();
        mPendingCheckForLongPress.rememberPressedState();
        // 向 Handler 队列中添加一个延迟执行的 Runnale。
        // delayOffset 一般为预按下的所消耗的时间。使长按的总时间保持一致。
        postDelayed(mPendingCheckForLongPress,
                ViewConfiguration.getLongPressTimeout() - delayOffset);
    }
}
```

一路深挖源码直至 performLongClickInternal() 方法。

```java
private boolean performLongClickInternal(float x, float y) {
        sendAccessibilityEvent(AccessibilityEvent.TYPE_VIEW_LONG_CLICKED);

        boolean handled = false;
        final ListenerInfo li = mListenerInfo;
        if (li != null && li.mOnLongClickListener != null) {
            // 执行 View 的长按监听回调。
            // 返回值用于标识该 View 是否已消费该事件流的长按事件。
            handled = li.mOnLongClickListener.onLongClick(View.this);
        }

        // 如果没消费，则显示一个长按的菜单。
        if (!handled) {
            final boolean isAnchored = !Float.isNaN(x) && !Float.isNaN(y);
            handled = isAnchored ? showContextMenu(x, y) : showContextMenu();
        }

        // 如果还没消费，并使用了 TOOLTIP，则显示 TOOLTIP 的内容。
        if ((mViewFlags & TOOLTIP) == TOOLTIP) {
            if (!handled) {
                handled = showLongClickTooltip((int) x, (int) y);
            }
        }
        if (handled) {
            performHapticFeedback(HapticFeedbackConstants.LONG_PRESS);
        }
        return handled;
    }
```


### ViewGroup 的 dispatchTouchEvent()

当 ViewGroup 的 dispatchTouchEvent() 返回false时，表示它或它的子View不接管事件流。

以下代码非所有源代码，只保留了主干源码。

```java
public boolean dispatchTouchEvent(MotionEvent ev) {
    if (mInputEventConsistencyVerifier != null) {
        mInputEventConsistencyVerifier.onTouchEvent(ev, 1);
    }

    // If the event targets the accessibility focused view and this is it, start
    // normal event dispatch. Maybe a descendant is what will handle the click.
    if (ev.isTargetAccessibilityFocus() && isAccessibilityFocusedViewOrHost()) {
        ev.setTargetAccessibilityFocus(false);
    }

    boolean handled = false;

    // 为了确保触摸事件的安全，防止存在悬浮窗监听触摸事件。
    if (onFilterTouchEventForSecurity(ev)) {
        final int action = ev.getAction();
        final int actionMasked = action & MotionEvent.ACTION_MASK;

        if (actionMasked == MotionEvent.ACTION_DOWN) {
            // 当用户初次按下（因为事件的开始都从 MotionEvent.ACTION_DOWN 开始）,
            // 清空 TouchTargets 以及 FLAG_DISALLOW_INTERCEPT 标记。
            // TouchTarget：每一个子 View 的 MotionEvent 是被哪一个 pointer 按下的。
            // FLAG_DISALLOW_INTERCEPT：用于子 View 向父 View 表示不希望父View拦截自己的事件。
            cancelAndClearTouchTargets(ev);
            resetTouchState();
        }

        // 是否拦截。
        final boolean intercepted;
        // 如果是按下事件或者已存在一个某一个子View被按下（被该子View消费），
        // 为true时才需要判断是否对事件进行拦截。
        if (actionMasked == MotionEvent.ACTION_DOWN
                || mFirstTouchTarget != null) {
            // disallowIntercept为true时：子 View 向父 View 表示不希望父View拦截自己的事件。
            final boolean disallowIntercept = (mGroupFlags & FLAG_DISALLOW_INTERCEPT) != 0;
            if (!disallowIntercept) {
                // 父View是否拦截该事件。
                intercepted = onInterceptTouchEvent(ev);
                ev.setAction(action); // restore action in case it was changed
            } else {
                intercepted = false;
            }
        } else {
            // 执行到这里，说明父View 在 ACTION_DOWN便进行了拦截；
            // 或者在ACTION_DOWN时，该ViewGroup没有子 View或没有子 View对事件进行消费；
            // 使子 View 永远接触不到该事件流。
            intercepted = true;
        }

      	// 如果事件被该 ViewGroup 拦截或已存在一个子View被按下。
        if (intercepted || mFirstTouchTarget != null) {
            // 关闭通过事件进行焦点获取。
            ev.setTargetAccessibilityFocus(false);
        }

        // 检查事件是否被取消(ACTION_CANCEL).
        final boolean canceled = resetCancelNextUpFlag(this)
                || actionMasked == MotionEvent.ACTION_CANCEL;

        // Update list of touch targets for pointer down, if needed.
        final boolean split = (mGroupFlags & FLAG_SPLIT_MOTION_EVENTS) != 0;
        TouchTarget newTouchTarget = null;
        boolean alreadyDispatchedToNewTouchTarget = false;

        // 如果没有取消也没有被拦截	(进入事件分发)
        if (!canceled && !intercepted) {

            // 如果事件是针对可访问性焦点视图，我们将其提供给具有可访问性焦点的 View。
            // 如果它不处理它，我们清除该标志并像往常一样将事件分派给所有的 ChildView。
            // 我们检测并避免保持这种状态，因为这个情况非常罕见。
            View childWithAccessibilityFocus = ev.isTargetAccessibilityFocus()
                    ? findChildWithAccessibilityFocus() : null;

            // 如果是一个按下事件时，是如何将该事件分配哪个子View。
            if (actionMasked == MotionEvent.ACTION_DOWN
                    || (split && actionMasked == MotionEvent.ACTION_POINTER_DOWN)
                    || actionMasked == MotionEvent.ACTION_HOVER_MOVE) {
                // 每一次以 ACTION_DOWN 事件开始，actionIndex都从 0 开始标记。
                final int actionIndex = ev.getActionIndex(); 
                // idBitsToAssign 相当于每一个MotionEvent 的身份证 作为唯一标识。
                final int idBitsToAssign = split ? 1 << ev.getPointerId(actionIndex)
                        : TouchTarget.ALL_POINTER_IDS;

                // 清除此指针ID的早期触摸目标，防止不同步。
                removePointersFromTouchTargets(idBitsToAssign);

                final int childrenCount = mChildrenCount;
                if (newTouchTarget == null && childrenCount != 0) {
                    final float x = ev.getX(actionIndex);
                    final float y = ev.getY(actionIndex);
                    // 写在xml布局最后的View不一定是最后绘制完成的View，此处拿到的是以绘制完成作为排序标准的所有子 View。
                    // 从前向后扫描子View（前为先绘制完成的View）
                    final ArrayList<View> preorderedList = buildTouchDispatchChildList();
                    final boolean customOrder = preorderedList == null
                            && isChildrenDrawingOrderEnabled();
                    final View[] children = mChildren;
                    // 从最上面的View 向被覆盖的View遍历。
                    for (int i = childrenCount - 1; i >= 0; i--) {
                        final int childIndex = getAndVerifyPreorderedIndex(
                                childrenCount, i, customOrder);
                        final View child = getAndVerifyPreorderedView(
                                preorderedList, children, childIndex);

                        // 如果有一个视图具有可访问性焦点，我们希望它首先获取事件，
                      	// 如果不处理，我们将执行正常的分派。 
                        // 尽管这可能会分发两次，但它能保证在给定的时间内更安全的执行。
                        if (childWithAccessibilityFocus != null) {
                            if (childWithAccessibilityFocus != child) {
                                continue;
                            }
                            childWithAccessibilityFocus = null;
                            i = childrenCount - 1;
                        }

                        // 如果事件的坐标不在子 View的绘制范围内，
                        // 或View不允许接受事件(即不处于显示状态(VISIBLE)或者未播放动画)，
                        // 则跳出语句询问下一个子View。                      
                        if (!canViewReceivePointerEvents(child)
                                || !isTransformedTouchPointInView(x, y, child, null)) {
                            ev.setTargetAccessibilityFocus(false);
                            continue;
                        }

                        newTouchTarget = getTouchTarget(child);
                        // 该子View 是否在之前事件中被触摸过（处于某一个事件）。
                        if (newTouchTarget != null) {
                            // 将新的事件添加到该子View的TouchTarget，并跳出。
                            newTouchTarget.pointerIdBits |= idBitsToAssign;
                            break;
                        }

                        resetCancelNextUpFlag(child);
                        // 调用子View 的dispatchTouchEvent(event)
                        if (dispatchTransformedTouchEvent(ev, false, child, idBitsToAssign)) {
                            mLastTouchDownTime = ev.getDownTime();
                            if (preorderedList != null) {
                                for (int j = 0; j < childrenCount; j++) {
                                    if (children[childIndex] == mChildren[j]) {
                                        mLastTouchDownIndex = j;
                                        break;
                                    }
                                }
                            } else {
                                mLastTouchDownIndex = childIndex;
                            }
                            mLastTouchDownX = ev.getX();
                            mLastTouchDownY = ev.getY();
                            // 添加一个新的 TouchTarget。
                            newTouchTarget = addTouchTarget(child, idBitsToAssign);
                            alreadyDispatchedToNewTouchTarget = true;
                            break;
                        }

                        // The accessibility focus didn't handle the event, so clear
                        // the flag and do a normal dispatch to all children.
                        ev.setTargetAccessibilityFocus(false);
                    }
                    if (preorderedList != null) preorderedList.clear();
                }

                if (newTouchTarget == null && mFirstTouchTarget != null) {
                    // 如果此时没有任何子View接受该事件，
                    // 将该事件自动添加给最近的 TouchTarget。
                    newTouchTarget = mFirstTouchTarget;
                    while (newTouchTarget.next != null) {
                        newTouchTarget = newTouchTarget.next;
                    }
                    newTouchTarget.pointerIdBits |= idBitsToAssign;
                }
            }
        }


        // 分发 TouchTarget 
        if (mFirstTouchTarget == null) {
            // 没有子 View 消费该事件流,
            // 则最终调用super.dispatchTouchEvent(event)，即将ViewGroup 看做 View。
            handled = dispatchTransformedTouchEvent(ev, canceled, null,
                    TouchTarget.ALL_POINTER_IDS);
        } else {
            // 如果存在某个子 View 消费过该事件流。
            // 发送到触摸目标，如果我们已经发送到目标，则排除新的触摸目标。必要时取消触摸目标
            TouchTarget predecessor = null;
            TouchTarget target = mFirstTouchTarget;
            while (target != null) {
                final TouchTarget next = target.next;
                if (alreadyDispatchedToNewTouchTarget && target == newTouchTarget) { 
                    // TouchTarget链表已存在某个View的TouchTarget（该View消费过某个事件），并且该View已消费本次事件。
                    // 设置handled为true，向父ViewGroup表示自己（ViewGroup）消费该事件。
                    handled = true;
                } else {
                    
                    final boolean cancelChild = resetCancelNextUpFlag(target.child)
                            || intercepted;
                    // 如果被自身（ViewGroup） 拦截，给子View发送一个ACTION_CANCEL，并向父 ViewGroup 表示自己消费该事件。
                    if (dispatchTransformedTouchEvent(ev, cancelChild,
                            target.child, target.pointerIdBits)) {
                        handled = true;
                    }
                    // 如果 cancelChild 为true（例如被自身拦截），释放所有子View的TouchTarget资源。
                    if (cancelChild) {
                        if (predecessor == null) {
                            mFirstTouchTarget = next;
                        } else {
                            predecessor.next = next;
                        }
                        target.recycle();
                        target = next;
                        continue;
                    }
                }
                // 遍历TouchTarget链表，更新链表事件结构。
                predecessor = target;
                target = next;
            }
        }

        if (canceled
                || actionMasked == MotionEvent.ACTION_UP
                || actionMasked == MotionEvent.ACTION_HOVER_MOVE) {
            // 如果是 ACTION_CANCEL或ACTION_UP事件（事件结束），重置状态。
            resetTouchState();
        } else if (split && actionMasked == MotionEvent.ACTION_POINTER_UP) {
            // 如果是 ACTION_POINTER_UP事件（有一个手指抬起），将该 PointerId 从 TouchTarget移除。
            final int actionIndex = ev.getActionIndex();
            final int idBitsToRemove = 1 << ev.getPointerId(actionIndex);
            removePointersFromTouchTargets(idBitsToRemove);
        }
    }

    if (!handled && mInputEventConsistencyVerifier != null) {
        mInputEventConsistencyVerifier.onUnhandledEvent(ev, 1);
    }
    return handled;
}
```




## 触摸反馈算法


 
# 参考资料

- [触摸反馈 - HenCoder](https://hencoder.com/ui-3-1/)
- [MotionEvent详解 - GcsSloop](http://www.gcssloop.com/customview/motionevent)