
<!-- TOC -->

- [一、MotionEvent](#%E4%B8%80motionevent)
  - [1.1 单点触控](#11-%E5%8D%95%E7%82%B9%E8%A7%A6%E6%8E%A7)
  - [1.2 多点触控](#12-%E5%A4%9A%E7%82%B9%E8%A7%A6%E6%8E%A7)
- [二、事件分发机制](#%E4%BA%8C%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91%E6%9C%BA%E5%88%B6)
  - [2.1 View 的事件分发机制](#21-view-%E7%9A%84%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91%E6%9C%BA%E5%88%B6)
    - [2.1.1 View.dispatchTouchEvent()](#211-viewdispatchtouchevent)
    - [2.1.2 View.onTouchEvent()](#212-viewontouchevent)
      - [2.1.2.1 View.checkForLongClick()](#2121-viewcheckforlongclick)
  - [2.2 ViewGroup 的事件分发机制](#22-viewgroup-%E7%9A%84%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91%E6%9C%BA%E5%88%B6)
- [三、触摸反馈算法](#%E4%B8%89%E8%A7%A6%E6%91%B8%E5%8F%8D%E9%A6%88%E7%AE%97%E6%B3%95)
  - [3.1 基本实现思路](#31-%E5%9F%BA%E6%9C%AC%E5%AE%9E%E7%8E%B0%E6%80%9D%E8%B7%AF)
  - [3.2 多点触控](#32-%E5%A4%9A%E7%82%B9%E8%A7%A6%E6%8E%A7)
    - [3.2.1 多点接力](#321-%E5%A4%9A%E7%82%B9%E6%8E%A5%E5%8A%9B)
    - [3.2.2 多点协作](#322-%E5%A4%9A%E7%82%B9%E5%8D%8F%E4%BD%9C)
    - [3.2.3 多点互不干扰](#323-%E5%A4%9A%E7%82%B9%E4%BA%92%E4%B8%8D%E5%B9%B2%E6%89%B0)
- [四、手势检测 GestureDetector](#%E5%9B%9B%E6%89%8B%E5%8A%BF%E6%A3%80%E6%B5%8B-gesturedetector)
  - [4.1 GestureDetector](#41-gesturedetector)
    - [4.1.1 OnGestureListener](#411-ongesturelistener)
    - [4.1.2 OnDoubleTapListener](#412-ondoubletaplistener)
    - [4.1.3 GestureDetector 常用方法](#413-gesturedetector-%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95)
  - [4.2 ScaleGestureDetector 缩放手势](#42-scalegesturedetector-%E7%BC%A9%E6%94%BE%E6%89%8B%E5%8A%BF)
    - [4.2.1 ScaleGestureDetector 常用方法](#421-scalegesturedetector-%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95)
  - [4.3 VelocityTracker 速度跟踪器](#43-velocitytracker-%E9%80%9F%E5%BA%A6%E8%B7%9F%E8%B8%AA%E5%99%A8)
- [五、滑动 Scroll](#%E4%BA%94%E6%BB%91%E5%8A%A8-scroll)
  - [5.1 scrollTo()/scrollBy()](#51-scrolltoscrollby)
  - [5.2 OverScroller](#52-overscroller)
    - [5.2.1 OverScroller.startScroll()](#521-overscrollerstartscroll)
    - [5.2.2 OverScroller.fling()](#522-overscrollerfling)
- [六、拖拽 Drag](#%E5%85%AD%E6%8B%96%E6%8B%BD-drag)
  - [6.1 OnDragListener](#61-ondraglistener)
  - [6.2 ViewDragHelper](#62-viewdraghelper)

<!-- /TOC -->

# 一、MotionEvent

## 1.1 单点触控

事件类型：

- ACTION_DOWN： 手指 **初次接触到屏幕时** 触发。
- ACTION_MOVE：手指在 **屏幕上滑动** 时触发，会多次触发。
- ACTION_UP：手指 **离开屏幕** 时触发。
- ACTION_CANCEL：事件 **被上层拦截** 时触发
- ACTION_OUTSIDE：手指 **不在控件区域** 时触发（例如 Dialog）。

方法：

- getAction()：获取事件类型。
- getX()：获得触摸点在当前 View 的 X 轴坐标。
- getY()：获得触摸点在当前 View 的 Y 轴坐标。
- getRawX()：获得触摸点在整个屏幕的 X 轴坐标。
- getRawY()：获得触摸点在整个屏幕的 Y 轴坐标。

## 1.2 多点触控

事件类型：

- ACTION_DOWN： **第一个** 手指 **接触到屏幕时** 触发；
- ACTION_MOVE：手指在 **屏幕上滑动** 时触发，会多次触发；
- ACTION_UP：**最后一个** 手指 **离开屏幕** 时触发；
- ACTION_POINTER_DOWN：有非主要的手指按下 (**即按下之前已经有手指在屏幕上**)；
- ACTION_POINTER_UP：有非主要的手指抬起 (即抬起之后仍然有手指在屏幕上)。

方法：

- getActionMasked()：与 getAction() 类似，多点触控必须使用这个方法获取事件类型；
- getActionIndex()：获取该事件以按下作为顺序时，第几个指针 (手指) 产生的（从 0 开始）；
- getPointerCount()：获取在屏幕上手指的个数；
- getPointerId(int pointerIndex)：获取一个指针 (手指) 的唯一标识符 ID，在手指按下和抬起之间 ID 始终不变；
- findPointerIndex(int pointerId)：通过 PointerId 获取到当前状态下 PointIndex，之后通过 PointIndex 获取其他数据；
- getX()：获取 pointerIndex 为 0 的指针 (手指) 的 X 坐标；
- getY()：获取 pointerIndex 为 0 的指针 (手指) 的 Y 坐标；
- getX(int pointerIndex)：获取某一个指针 (手指) 的 X 坐标；
- getY(int pointerIndex)：获取某一个指针 (手指) 的 Y 坐标。

多点触控将 index 属性和事件类型合并以一个 int 作为标识，用低 8 位 (0x000000ff) 表示事件类型，再往前的 8 位 (0x0000ff00) 表示事件编号。

追踪事件流，请认准 PointId，同一个手指在多点触控的过程中它的 ActionIndex 会变化。

- PointId 在手指按下时产生，手指抬起或者事件被取消后消失，通过 getPointerId(int pointerIndex) 记录 PointerId，在需要的时候通过 findPointerIndex() 再查找可能变化（手指抬起和按下）的 pointerIndex（因为大部分 API 的参数是 pointerIndex，例如 getX()）。
- 一个手指的 PointId 在经过按下->抬起->再按下时可能属于同一个 Id。
- 在手指移动的过程中（ACTION_MOVE 事件），是没有办法具体知道是哪个手指移动的，除非屏幕上只有一个手指。

# 二、事件分发机制

事件分发机制的大体流程：

1. ViewGroup 会从 Activity 开始到根布局再不断向子 View（ViewGroup） 询问是否接管事件流。
2. onTouchEvent() 和 onInterceptTouchEvent() 都是在 dispatchTouchEvent() 中调用，一个事件分发的过程本质上是从根 View 递归调用 dispatchTouchEvent() 的过程。
3. 最终根据 View 或 ViewGroup 的 dispatchTouchEvent() 方法的返回值取决于是否消费该事件。

事件分发的源码分析基于 Android SDK 28。

## 2.1 View 的事件分发机制

### 2.1.1 View.dispatchTouchEvent()

当 View 的 dispatchTouchEvent() 返回 false 时，表示不消费该事件流。

以下代码非所有源代码，只保留了主干源码。

```java
public boolean dispatchTouchEvent(MotionEvent event) {

    // 标记是否消费事件。
    boolean result = false;

    if (onFilterTouchEventForSecurity(event)) {
        // 如果该 View 处于可用，并且滑动了滚动条。
        if ((mViewFlags & ENABLED_MASK) == ENABLED && handleScrollBarDragging(event)) {
            result = true;
        }
        // 是否设置了 OnTouchListener，如果设置了调用 mOnTouchListener.onTouch(this, event),
        // 该方法可以选择返回 false，不消费事件。
        ListenerInfo li = mListenerInfo;
        if (li != null && li.mOnTouchListener != null
                && (mViewFlags & ENABLED_MASK) == ENABLED
                && li.mOnTouchListener.onTouch(this, event)) {
            result = true;
        }

        // 如果事件没被消费，调用 View 的 onTouchEvent(event)。
        if (!result && onTouchEvent(event)) {
            result = true;
        }
    }

    return result;
}
```

### 2.1.2 View.onTouchEvent()

```java
public boolean onTouchEvent(MotionEvent event) {
    final float x = event.getX();
    final float y = event.getY();
    final int viewFlags = mViewFlags;
    final int action = event.getAction();

    // 当前 View 是否可点击。
    // 判断标准为只要 CLICKABLE、LONG_CLICKABLE、CONTEXT_CLICKABLE（鼠标等）有一个被标记成 true。
    final boolean clickable = ((viewFlags & CLICKABLE) == CLICKABLE
            || (viewFlags & LONG_CLICKABLE) == LONG_CLICKABLE)
            || (viewFlags & CONTEXT_CLICKABLE) == CONTEXT_CLICKABLE;

    // 如果 View 被标记为不可用。
    if ((viewFlags & ENABLED_MASK) == DISABLED) {
        // View 不可用却 clickable 又为 true 时，直接消费事件，不再向下层 View 传递。
        return clickable;
    }

    // 设置触摸代理，将当前 View 的部分区域的事件处理按照代理 View 的逻辑（onTouchEvent()）去执行。
    if (mTouchDelegate != null) {
        if (mTouchDelegate.onTouchEvent(event)) {
            return true;
        }
    }

    // 如果可点击或使用了 TOOLTIP（长按当前 View 时会在长按的坐标上面提示一段信息，xml 的 API 为 tooltipText）。
    // 只要走进该方法，返回值都为 true，也就是说 clickable 为 true 或者使用了 TOOLTIP 都代表消费该事件。
    if (clickable || (viewFlags & TOOLTIP) == TOOLTIP) {
        switch (action) {
            case MotionEvent.ACTION_DOWN:
                // 如果该事件通过触摸屏幕得到，便标志为手指按下。
                if (event.getSource() == InputDevice.SOURCE_TOUCHSCREEN) {
                    mPrivateFlags3 |= PFLAG3_FINGER_DOWN;
                }
                mHasPerformedLongPress = false;

                // 如果不可点击，还走到了这里，说明使用了 TOOLTIP。
                if (!clickable) {
                    // 看到此，可先跳转到 checkForLongClick() 的代码分析。
                    // 该方法主要处理 OnLongClickListener、 Menu 和 TOOLTIP。 
                    // 此时调用该方法也是为了处理 TOOLTIP。
                    checkForLongClick(0, x, y);
                    break;
                }

                // 是否存在一个父 View 是可滑动的控件。
                // 没有滑动功能的 ViewGroup 可重写 shouldDelayChildPressedState() 返回 false 关闭预按下状态，提高其它事件的响应速度。
                boolean isInScrollingContainer = isInScrollingContainer();


                if (isInScrollingContainer) {
                    // 预按下状态，经过 100 毫秒后，才设置按下状态，并监听长按事件。
                    mPrivateFlags |= PFLAG_PREPRESSED;
                    if (mPendingCheckForTap == null) {
                        mPendingCheckForTap = new CheckForTap();
                    }
                    mPendingCheckForTap.x = event.getX();
                    mPendingCheckForTap.y = event.getY();
                    postDelayed(mPendingCheckForTap, ViewConfiguration.getTapTimeout());
                } else {
                    // 如果不是在滑动控件，直接设置按下状态，并监听长按事件。
                    // setPressed() 第一个参数的作用是是否产生按下的 drawable（水波纹）。
                    setPressed(true, x, y);
                    checkForLongClick(0, x, y);
                }
                break;

            case MotionEvent.ACTION_MOVE:
                // 更新水波纹 drawable 的位置。
                if (clickable) {
                    drawableHotspotChanged(x, y);
                }

                // pointInView()：移动的坐标是否超出 View 的绘制范围。
                // mTouchSlop：在超出 View 的绘制范围 mTouchSlop 个像素内依旧算移动该 View。
                // 当移除当前 View 的范围后，会取消一系列事件。
                if (!pointInView(x, y, mTouchSlop)) {

                    // 取消预按下事件 Runnable。
                    removeTapCallback();
                    // 取消长按事件 Runnable。
                    removeLongPressCallback();
                    // 取消按下的 drawable 效果。
                    if ((mPrivateFlags & PFLAG_PRESSED) != 0) {
                        setPressed(false);
                    }
                    // 清理 TOOLTIP 标记。
                    mPrivateFlags3 &= ~PFLAG3_FINGER_DOWN;
                }
                break;

            case MotionEvent.ACTION_UP:
                // 清理 TOOLTIP 标记。
                mPrivateFlags3 &= ~PFLAG3_FINGER_DOWN;

                // 如果使用了 TOOLTIP，则对 TOOLTIP 进行相关资源回收（UI 方面表现为 1500ms 后显示的字体消失）。
                if ((viewFlags & TOOLTIP) == TOOLTIP) {
                    handleTooltipUp();
                }
                // 如果不可点击，回收资源，不再往下执行。
                if (!clickable) {
                    // 这里主要移除 TOOLTIP 相关的 Runnable。
                    removeTapCallback();
                    removeLongPressCallback();
                    mInContextButtonPress = false;
                    mHasPerformedLongPress = false;
                    mIgnoreNextUpEvent = false;
                    break;
                }

                // prepressed 为 true 表示用户处于预按下状态，就抬起了手。
                boolean prepressed = (mPrivateFlags & PFLAG_PREPRESSED) != 0;
                if ((mPrivateFlags & PFLAG_PRESSED) != 0 || prepressed) {
                    boolean focusTaken = false;
                    // 如果当前 View 支持触摸获取焦点，并且没有获取到焦点。
                    if (isFocusable() && isFocusableInTouchMode() && !isFocused()) {
                        // 尝试获取焦点。
                        focusTaken = requestFocus();
                    }

                    // 设置为按下状态，显示 drawable 效果，让用户知道他曾经按下过。
                    if (prepressed) {
                        setPressed(true, x, y);
                    }

                    // mHasPerformedLongPress 为 true 表示消费了长按事件，则不再响应点击事件。
                    if (!mHasPerformedLongPress && !mIgnoreNextUpEvent) {
                        // 长按事件默认会在 1500ms 后响应，在 1500ms 内抬起了手，移除长按事件的 Runnable。
                        removeLongPressCallback();

                        // 如果获取到了焦点，则不再响应点击事件。
                        // 例如点击 EditText 的输入框，优先获取焦点，若焦点获取成功，则不再响应点击事件。
                        if (!focusTaken) {
                            if (mPerformClick == null) {
                                mPerformClick = new PerformClick();
                            }
                            if (!post(mPerformClick)) {
                                performClickInternal();
                            }
                        }
                    }

                    if (mUnsetPressedState == null) {
                        mUnsetPressedState = new UnsetPressedState();
                    }
                    if (prepressed) {
                        // 处于预按下的状态便抬手，便在 64 ms 毫秒后，设置为未按下状态，关闭 drawable 效果。
                        postDelayed(mUnsetPressedState,
                                ViewConfiguration.getPressedStateDuration());
                    } else if (!post(mUnsetPressedState)) {
                        // 否则直接关闭 drawable 效果。
                        mUnsetPressedState.run();
                    }

                    // 移除 TapCallback，当用户设置了长按监听，并不消费长按事件时还使用了 TOOLTIP，
                    // 便可能触发显示 TOOLTIP 的 Runnable。
                    removeTapCallback();
                }
                mIgnoreNextUpEvent = false;
                break;

            case MotionEvent.ACTION_CANCEL:
                // Drawable 恢复未按压状态、重置各类标记、移除各类 Runnable。
                if (clickable) {
                    setPressed(false);
                }
                removeTapCallback();
                removeLongPressCallback();
                mInContextButtonPress = false;
                mHasPerformedLongPress = false;
                mIgnoreNextUpEvent = false;
                mPrivateFlags3 &= ~PFLAG3_FINGER_DOWN;
                break;
        }

        return true;
    }

    return false;
}
```

#### 2.1.2.1 View.checkForLongClick()

```java
private void checkForLongClick(int delayOffset, float x, float y) {

    if ((mViewFlags & LONG_CLICKABLE) == LONG_CLICKABLE || (mViewFlags & TOOLTIP) == TOOLTIP) {
        mHasPerformedLongPress = false;

        if (mPendingCheckForLongPress == null) {
            // CheckForLongPress 为一个 Runnable。
            mPendingCheckForLongPress = new CheckForLongPress();
        }
        mPendingCheckForLongPress.setAnchor(x, y);
        mPendingCheckForLongPress.rememberWindowAttachCount();
        mPendingCheckForLongPress.rememberPressedState();
        // 向 Handler 队列中添加一个延迟执行的 Runnable。
        // delayOffset 一般为预按下的所消耗的时间。使长按的总时间保持一致。
        postDelayed(mPendingCheckForLongPress,
                ViewConfiguration.getLongPressTimeout() - delayOffset);
    }
}
```

一路深挖源码直至 performLongClickInternal() 方法。

```java
private boolean performLongClickInternal(float x, float y) {
        sendAccessibilityEvent(AccessibilityEvent.TYPE_VIEW_LONG_CLICKED);

        boolean handled = false;
        final ListenerInfo li = mListenerInfo;
        if (li != null && li.mOnLongClickListener != null) {
            // 执行 View 的长按监听回调。
            // 返回值用于标识该 View 是否已消费该事件流的长按事件。
            handled = li.mOnLongClickListener.onLongClick(View.this);
        }

        // 如果没消费，则显示一个长按的菜单。
        if (!handled) {
            final boolean isAnchored = !Float.isNaN(x) && !Float.isNaN(y);
            handled = isAnchored ? showContextMenu(x, y) : showContextMenu();
        }

        // 如果还没消费，并使用了 TOOLTIP，则显示 TOOLTIP 的内容。
        if ((mViewFlags & TOOLTIP) == TOOLTIP) {
            if (!handled) {
                handled = showLongClickTooltip((int) x, (int) y);
            }
        }
        if (handled) {
            performHapticFeedback(HapticFeedbackConstants.LONG_PRESS);
        }
        return handled;
    }
```

## 2.2 ViewGroup 的事件分发机制

当 ViewGroup 的 dispatchTouchEvent() 返回 false 时，表示它和它的子 View 都不接管事件流。

以下代码非所有源代码，只保留了主干源码。

```java
public boolean dispatchTouchEvent(MotionEvent ev) {
    if (mInputEventConsistencyVerifier != null) {
        mInputEventConsistencyVerifier.onTouchEvent(ev, 1);
    }

    // If the event targets the accessibility focused view and this is it, start
    // normal event dispatch. Maybe a descendant is what will handle the click.
    if (ev.isTargetAccessibilityFocus() && isAccessibilityFocusedViewOrHost()) {
        ev.setTargetAccessibilityFocus(false);
    }

    boolean handled = false;

    // 为了确保触摸事件的安全，防止存在悬浮窗监听触摸事件。
    if (onFilterTouchEventForSecurity(ev)) {
        final int action = ev.getAction();
        final int actionMasked = action & MotionEvent.ACTION_MASK;

        if (actionMasked == MotionEvent.ACTION_DOWN) {
            // 当用户初次按下（因为事件的开始都从 MotionEvent.ACTION_DOWN 开始）,
            // 清空 TouchTargets 以及 FLAG_DISALLOW_INTERCEPT 标记。
            // TouchTarget：每一个子 View 是被哪些 pointer 按下的（以 View 为单位）。
            // FLAG_DISALLOW_INTERCEPT：用于子 View 向父 View 表示不希望父 View 拦截自己的事件。
            cancelAndClearTouchTargets(ev);
            resetTouchState();
        }

        // 是否拦截。
        final boolean intercepted;
        // 如果是按下事件或者已存在一个某一个子 View 被按下（被该子 View 消费），
        // 为 true 时才需要判断是否对事件进行拦截。
        // 当父 View 获取到事件流后，mFirstTouchTarget 会被置为 null。
        if (actionMasked == MotionEvent.ACTION_DOWN
                || mFirstTouchTarget != null) {
            // disallowIntercept 为 true 时：子 View 向父 View 表示不希望父 View 拦截自己的事件。
            final boolean disallowIntercept = (mGroupFlags & FLAG_DISALLOW_INTERCEPT) != 0;
            if (!disallowIntercept) {
                // 父 View 是否拦截该事件。
                intercepted = onInterceptTouchEvent(ev);
                ev.setAction(action); // restore action in case it was changed
            } else {
                intercepted = false;
            }
        } else {
            // 执行到这里，说明
            // 1. 父 View 进行了拦截；
            // 2. 或者在 ACTION_DOWN 时，该 ViewGroup 没有子 View 或没有子 View 对事件进行消费。
            // 使子 View 永远接触不到该事件流。
            intercepted = true;
        }

      	// 如果事件被该 ViewGroup 拦截或已存在一个子 View 接受了 ACTION_DOWN 事件。
        if (intercepted || mFirstTouchTarget != null) {
            // 关闭通过事件进行焦点获取。
            ev.setTargetAccessibilityFocus(false);
        }

        // 检查事件流是否被取消(ACTION_CANCEL)。
        final boolean canceled = resetCancelNextUpFlag(this)
                || actionMasked == MotionEvent.ACTION_CANCEL;

        // Update list of touch targets for pointer down, if needed.
        final boolean split = (mGroupFlags & FLAG_SPLIT_MOTION_EVENTS) != 0;
        TouchTarget newTouchTarget = null;
        boolean alreadyDispatchedToNewTouchTarget = false;

        // 如果没有取消也没有被拦截（进入事件分发）
        if (!canceled && !intercepted) {

            // 如果事件是针对可访问性焦点视图，我们将其提供给具有可访问性焦点的 View。
            // 如果它不处理它，我们清除该标志并像往常一样将事件分派给所有的 ChildView。
            // 我们检测并避免保持这种状态，因为这个情况非常罕见。
            View childWithAccessibilityFocus = ev.isTargetAccessibilityFocus()
                    ? findChildWithAccessibilityFocus() : null;

            // 如果是一个按下事件时，是如何将该事件分配哪个子 View。
            if (actionMasked == MotionEvent.ACTION_DOWN
                    || (split && actionMasked == MotionEvent.ACTION_POINTER_DOWN)
                    || actionMasked == MotionEvent.ACTION_HOVER_MOVE) {
                // 每一次以 ACTION_DOWN 事件开始，actionIndex 都从 0 开始标记。
                final int actionIndex = ev.getActionIndex(); 
                // idBitsToAssign 相当于每一个 MotionEvent 的身份证，作为唯一标识。
                final int idBitsToAssign = split ? 1 << ev.getPointerId(actionIndex)
                        : TouchTarget.ALL_POINTER_IDS;

                // 清除此指针 ID 的早期触摸目标，防止不同步。
                removePointersFromTouchTargets(idBitsToAssign);

                final int childrenCount = mChildrenCount;
                if (newTouchTarget == null && childrenCount != 0) {
                    final float x = ev.getX(actionIndex);
                    final float y = ev.getY(actionIndex);
                    // 写在 xml 布局最后的 View 不一定是最后绘制完成的 View，此处拿到的是以绘制完成作为排序标准的所有子 View。
                    // 从前向后扫描子 View（前为先绘制完成的 View）。
                    final ArrayList<View> preorderedList = buildTouchDispatchChildList();
                    final boolean customOrder = preorderedList == null
                            && isChildrenDrawingOrderEnabled();
                    final View[] children = mChildren;
                    // 从最上面的 View 向被覆盖的 View 遍历。
                    for (int i = childrenCount - 1; i >= 0; i--) {
                        final int childIndex = getAndVerifyPreorderedIndex(
                                childrenCount, i, customOrder);
                        final View child = getAndVerifyPreorderedView(
                                preorderedList, children, childIndex);

                        // 如果有一个视图具有可访问性焦点，我们希望它首先获取事件，
                      	// 如果不处理，我们将执行正常的分派。 
                        // 尽管这可能会分发两次，但它能保证在给定的时间内更安全的执行。
                        if (childWithAccessibilityFocus != null) {
                            if (childWithAccessibilityFocus != child) {
                                continue;
                            }
                            childWithAccessibilityFocus = null;
                            i = childrenCount - 1;
                        }

                        // 以下 2 种情况的子 View 不接受事件：
                        // 1、不可见的时候又没有设置动画。
                        // 2、该子 View 不处于可接受事件的坐标范围内，逻辑如下：
                        // 2.1 会先调用子 View 的 hasIdentityMatrix 方法来判断这个 View 是否应用过位移、缩放、旋转之类的属性动画；
                        // 2.2 如果应用过的话，那接下来还会把触摸点映射到该子 View 的逆矩阵上(getInverseMatrix)，如果没有应用过则直接使用触摸点的坐标；
                        // 2.3 判断处理后的触摸点，是否在该子 View 的边界范围内。
                        if (!canViewReceivePointerEvents(child)
                                || !isTransformedTouchPointInView(x, y, child, null)) {
                            ev.setTargetAccessibilityFocus(false);
                            continue;
                        }

                        newTouchTarget = getTouchTarget(child);
                        // 该子 View 是否在被触摸过（在当前事件流处于某一个事件）。
                        if (newTouchTarget != null) {
                            // 将新的事件添加到该子 View 的 TouchTarget，并跳出。
                            newTouchTarget.pointerIdBits |= idBitsToAssign;
                            break;
                        }

                        resetCancelNextUpFlag(child);
                
                        // 找到合适的子 View 之后，调用子 View 的 dispatchTouchEvent(event)。
                        if (dispatchTransformedTouchEvent(ev, false, child, idBitsToAssign)) {
                            mLastTouchDownTime = ev.getDownTime();
                            if (preorderedList != null) {
                                for (int j = 0; j < childrenCount; j++) {
                                    if (children[childIndex] == mChildren[j]) {
                                        mLastTouchDownIndex = j;
                                        break;
                                    }
                                }
                            } else {
                                mLastTouchDownIndex = childIndex;
                            }
                            mLastTouchDownX = ev.getX();
                            mLastTouchDownY = ev.getY();
                            // 添加一个新的 TouchTarget，并将它赋值给 mFirstTouchTarget，
                            // 表示最近一次触摸的 子 View。
                            newTouchTarget = addTouchTarget(child, idBitsToAssign);
                            alreadyDispatchedToNewTouchTarget = true;
                            break;
                        }

                        // The accessibility focus didn't handle the event, so clear
                        // the flag and do a normal dispatch to all children.
                        ev.setTargetAccessibilityFocus(false);
                    }
                    if (preorderedList != null) preorderedList.clear();
                }

                if (newTouchTarget == null && mFirstTouchTarget != null) {
                    // 如果此时没有任何子 View 接受该事件，
                    // 将该事件自动添加给最近的 TouchTarget。
                    newTouchTarget = mFirstTouchTarget;
                    while (newTouchTarget.next != null) {
                        newTouchTarget = newTouchTarget.next;
                    }
                    newTouchTarget.pointerIdBits |= idBitsToAssign;
                }
            }
        }


        // 分发 TouchTarget。
        if (mFirstTouchTarget == null) {
            // mFirstTouchTarget == null，说明没有子 View 消费过事件流,
            // 则最终调用 super.dispatchTouchEvent(event)，即将 ViewGroup 看做 View。
            handled = dispatchTransformedTouchEvent(ev, canceled, null,
                    TouchTarget.ALL_POINTER_IDS);
        } else {
            // 如果存在某个子 View 消费过该事件流。
            
            TouchTarget predecessor = null;
            TouchTarget target = mFirstTouchTarget;
            while (target != null) {
                final TouchTarget next = target.next;
                if (alreadyDispatchedToNewTouchTarget && target == newTouchTarget) { 
                    // 调用到这里说明该次事件为某个子 View 的第一个事件（ACTION_DOWM 或 ACTION_POINTER_DOWN），已在构建该子 View 的 TouchTarget 时便发送到事件到该 View。
                    // 设置 handled 为 true，向父 ViewGroup 表示自己（ViewGroup）消费该事件。
                    handled = true;
                } else {
                    // 调用到这里说明该次事件非 ACTION_DOWM 或 ACTION_POINTER_DOWN。
                    
                    final boolean cancelChild = resetCancelNextUpFlag(target.child)
                            || intercepted;
                    // 如果 cancelChild 为 true，给子 View 发送一个 ACTION_CANCEL，并向父 ViewGroup 表示自己消费该事件。
                    // 如果 cancelChild 为 false，将新的事件发送给目标子 View。
                    if (dispatchTransformedTouchEvent(ev, cancelChild,
                            target.child, target.pointerIdBits)) {
                        handled = true;
                    }
                    // 如果 cancelChild 为 true（例如被自身拦截），释放所有子 View 的 TouchTarget 资源。
                    if (cancelChild) {
                        if (predecessor == null) {
                            mFirstTouchTarget = next;
                        } else {
                            predecessor.next = next;
                        }
                        target.recycle();
                        target = next;
                        continue;
                    }
                }
                // 遍历该 View 的 TouchTarget 链表，更新链表事件结构。
                predecessor = target;
                target = next;
            }
        }

        if (canceled
                || actionMasked == MotionEvent.ACTION_UP
                || actionMasked == MotionEvent.ACTION_HOVER_MOVE) {
            // 如果是 ACTION_CANCEL 或 ACTION_UP 事件（事件结束），重置状态。
            resetTouchState();
        } else if (split && actionMasked == MotionEvent.ACTION_POINTER_UP) {
            // 如果是 ACTION_POINTER_UP 事件（有一个手指抬起），将该 PointerId 从 TouchTarget 移除。
            final int actionIndex = ev.getActionIndex();
            final int idBitsToRemove = 1 << ev.getPointerId(actionIndex);
            removePointersFromTouchTargets(idBitsToRemove);
        }
    }

    if (!handled && mInputEventConsistencyVerifier != null) {
        mInputEventConsistencyVerifier.onUnhandledEvent(ev, 1);
    }
    return handled;
}
```

# 三、触摸反馈算法

## 3.1 基本实现思路

手写触摸反馈算法的大体流程：

1. 重写 onTouchEvent()，在里面写上你的触摸反馈算法，并返回 true（是否消费事件取决于 ACTION_DOWN 事件或 ACTION_POINTER_DOWN 时是否返回 true），如果返回 false，则在这组触摸事件流中永不接管当前事件流。
2. 如果是会发生触摸冲突的 ViewGroup，还需要重写 onInterceptTouchEvent()，在事件流开始时返回 false，并在确认接管事件流时返回一次 true，以实现对事件的拦截和接管，并在接管之后对它的子 View 发送一个额外的取消事件 CANCEL。
3. **在一个事件序列的开始（ACTION_DOWN）**，若子 View 临时需要父 View 不拦截事件，则可以调用父 View 的 requestDisallowInterceptTouchEvent() ，通知父 View 在当前事件流中别拦截，该方法会递归通知每一级父 View。

编写触摸反馈算法的注意事项：

1. 对于 ViewGroup 来说，onInterceptTouchEvent() 和 onTouchEvent() 的 ACTION_DOWM 事件的逻辑基本或完全一致。因为 ACTION_DOWM 事件做起到起始记录的作用，而这 2 个方法的调用时机是变化的，会造成 onTouchEvent() 可能不会被调用或程序状态有误。
2. ACITON_MOVE 事件一般用于确认滑动，为了减小用户误触摸操作或确认 ViewGroup 需要的滑动限制，使用 Math.abs(event.getX()-downX)>ViewConfiguration.getXXXSlop() 确认。

## 3.2 多点触控

多点触控的实现原因分为两种：一直是以兼容为主，这种情况一般都是单点触控的需求，但需要在多点触控出现时，能够平滑过渡或不影响原来的单点触控逻辑，例如下面 3.2.1 的例子；另一种则是真正的需求使然，例如常见的图片双指放缩、小米系统的三指快速截屏等。

### 3.2.1 多点接力

该种方式用于只针对单点触摸算法的编写，但又需要兼容多点触摸的场景，达到类似于触摸点接力的效果。

实现思路：

1. 在 MotionEvent.ACTION_DOWN 和 MotionEvent.ACTION_POINTER_DOWN 事件中记录最新活跃的点的 PointerId（跟踪点），并对需要的数据（例如按下的位置、上次的偏移量）进行记录；
2. 在 ACTION_MOVE 事件执行触摸逻辑；
3. 若正在活跃的点抬起（MotionEvent.ACTION_POINTER_UP 事件），则为跟踪点寻找新的点（一般为除了抬起的点外最近按下的点），并执行第 1 步的代码（相当于开发者主观让该手指按下）。

本例需求：以活跃的手指为中心滑动图像，若该活跃手指抬起则平滑的将活跃点转移到其它手指。

```java
public class MultiTouchView1 extends View {
    private static final float IMAGE_WIDTH = Utils.dpToPixel(200);

    Paint paint = new Paint(Paint.ANTI_ALIAS_FLAG);
    Bitmap bitmap;

    float downX;
    float downY;
    float offsetX;
    float offsetY;
    float originalOffsetX;
    float originalOffsetY;
    int trackingPointerId;

    public MultiTouchView1(Context context, @Nullable AttributeSet attrs) {
        super(context, attrs);

        bitmap = Utils.getAvatar(getResources(), (int) IMAGE_WIDTH);
    }

    @Override
    public boolean onTouchEvent(MotionEvent event) {
        switch (event.getActionMasked()) {
            case MotionEvent.ACTION_DOWN:
                trackingPointerId = event.getPointerId(0);
                downX = event.getX();
                downY = event.getY();
                originalOffsetX = offsetX;
                originalOffsetY = offsetY;
                break;
            case MotionEvent.ACTION_MOVE:
                int index = event.findPointerIndex(trackingPointerId);
                offsetX = originalOffsetX + event.getX(index) - downX;
                offsetY = originalOffsetY + event.getY(index) - downY;
                invalidate();
                break;
            case MotionEvent.ACTION_POINTER_DOWN:
                int actionIndex = event.getActionIndex();
                trackingPointerId = event.getPointerId(actionIndex);
                downX = event.getX(actionIndex);
                downY = event.getY(actionIndex);
                originalOffsetX = offsetX;
                originalOffsetY = offsetY;
                break;
            case MotionEvent.ACTION_POINTER_UP:
                actionIndex = event.getActionIndex();
                int pointerId = event.getPointerId(actionIndex);
                if (pointerId == trackingPointerId) {
                    // 跟踪的点（pointerId）抬起了，因此需要一个新的点接力。
                    int newIndex;
                    if (actionIndex == event.getPointerCount() - 1) {
                        // 说明抬起的点为最近按下的点，因此需要取该点更早按下的点，所以 -2。
                        newIndex = event.getPointerCount() - 2;
                    } else {
                        // 取最近按下的点。
                        newIndex = event.getPointerCount() - 1;
                    }
                    trackingPointerId = event.getPointerId(newIndex);
                    downX = event.getX(actionIndex);
                    downY = event.getY(actionIndex);
                    originalOffsetX = offsetX;
                    originalOffsetY = offsetY;
                }
                break;
        }
        return true;
    }

    @Override
    protected void onDraw(Canvas canvas) {
        canvas.drawBitmap(bitmap, offsetX, offsetY, paint);
    }
}

```

### 3.2.2 多点协作

多点协作用于发生多点触控时，需要 **同时** 对屏幕上的点的坐标进行需求运算。

本例需求：以多点的中心作为图像滑动中心。

```java
public class MultiTouchView2 extends View {
    private static final float IMAGE_WIDTH = Utils.dpToPixel(200);

    Paint paint = new Paint(Paint.ANTI_ALIAS_FLAG);
    Bitmap bitmap;

    float downX;
    float downY;
    float offsetX;
    float offsetY;
    float originalOffsetX;
    float originalOffsetY;

    public MultiTouchView2(Context context, @Nullable AttributeSet attrs) {
        super(context, attrs);

        bitmap = Utils.getAvatar(getResources(), (int) IMAGE_WIDTH);
    }

    @Override
    public boolean onTouchEvent(MotionEvent event) {
        float sumX = 0;
        float sumY = 0;
        // 多点协作，需要拿到当前屏幕上的手指个数（该数量也会包含 ACTION_POINTER_UP 事件的手指，也就是刚抬起来的手指）。
        int pointerCount = event.getPointerCount();
        boolean isPointerUp = event.getActionMasked() == MotionEvent.ACTION_POINTER_UP;
        for (int i = 0; i < pointerCount; i++) {
            if (!(isPointerUp && i == event.getActionIndex())) {
                // 分别拿到现在屏幕上所有手指的坐标进行需求运算。
                sumX += event.getX(i);
                sumY += event.getY(i);
            }
        }

        if (isPointerUp) {
            pointerCount -= 1;
        }
        // 计算多点的中心坐标。
        float focusX = sumX / pointerCount;
        float focusY = sumY / pointerCount;
        switch (event.getActionMasked()) {
            case MotionEvent.ACTION_DOWN:
            case MotionEvent.ACTION_POINTER_DOWN:
            case MotionEvent.ACTION_POINTER_UP:
                downX = focusX;
                downY = focusY;
                originalOffsetX = offsetX;
                originalOffsetY = offsetY;
                break;
            case MotionEvent.ACTION_MOVE:
                offsetX = originalOffsetX + focusX - downX;
                offsetY = originalOffsetY + focusY - downY;
                invalidate();
                break;
        }
        return true;
    }

    @Override
    protected void onDraw(Canvas canvas) {
        canvas.drawBitmap(bitmap, offsetX, offsetY, paint);
    }
}
```

### 3.2.3 多点互不干扰

本例需求：画图功能，且支持多个手指同时画图，多点之间互不影响，在手指抬起后清掉该手指的绘制路径。

```java
public class MultiTouchView3 extends View {
    Paint paint = new Paint(Paint.ANTI_ALIAS_FLAG);

    SparseArray<Path> paths = new SparseArray<>();

    public MultiTouchView3(Context context, @Nullable AttributeSet attrs) {
        super(context, attrs);
    }

    {
        paint.setStyle(Paint.Style.STROKE);
        paint.setStrokeWidth(Utils.dpToPixel(4));
        paint.setStrokeCap(Paint.Cap.ROUND);
        paint.setStrokeJoin(Paint.Join.ROUND);
    }

    @Override
    public boolean onTouchEvent(MotionEvent event) {
        switch (event.getActionMasked()) {
            case ACTION_DOWN:
            case ACTION_POINTER_DOWN:
                int actionIndex = event.getActionIndex();
                int pointerId = event.getPointerId(actionIndex);
                Path path = new Path();
                // 以按下的坐标作为 path 的起点。
                path.moveTo(event.getX(actionIndex), event.getY(actionIndex));
                paths.append(pointerId, path);
                invalidate();
                break;
            case ACTION_MOVE:
                // 由于 ACTION_MOVE 事件是不知道具体是哪个手指移动，因此需要遍历。
                for (int i = 0; i < event.getPointerCount(); i++) {
                    pointerId = event.getPointerId(i);
                    path = paths.get(pointerId);
                    // 每个手指的移动只取自己手指坐标的变化。
                    path.lineTo(event.getX(i), event.getY(i));
                }
                invalidate();
                break;
            case ACTION_UP:
            case ACTION_POINTER_UP:
                pointerId = event.getPointerId(event.getActionIndex());
                paths.remove(pointerId);
                invalidate();
                break;
        }
        return true;
    }

    @Override
    protected void onDraw(Canvas canvas) {
        for (int i = 0; i < paths.size(); i++) {
            Path path = paths.valueAt(i);
            canvas.drawPath(path, paint);
        }
    }
}
```

# 四、手势检测 GestureDetector 

## 4.1 GestureDetector

GestureDetector 可以根据传入的 MotionEvents 识别各种常用的手势。

GestureDetecotr 主要用的有三种监听器：OnDoubleTapListener、OnGestureListener、SimpleOnGestureListener。

SimpleOnGestureListener 为其它两种监听器的空实现，一般情况下可以直接使用 SimpleOnGestureListener。

### 4.1.1 OnGestureListener

```java
public interface OnGestureListener {

    /**
     * 每次 ACTION_DOWM 事件都会回调，
     * 返回 true 表示消费该事件。
     */
    boolean onDown(MotionEvent e);

    /**
     * 按下 100ms 不松手后被调用。
     */
    void onShowPress(MotionEvent e);

    /**
     * 单击时被调用（长按松手不触发、双击第二次不触发）。
     * 返回 true 表示消费该事件。
     */
    boolean onSingleTapUp(MotionEvent e);

    /**
     * 滑动时调用。
     * 
     * @param e1 :按下时的 ACTION_DOWM 事件。
     * @param e2 :当前事件。
     * @param distanceX :按下时的偏移 x 轴坐标 - 当前事件的 x 轴坐标。
     * @param distanceY :按下时的偏移 y 轴坐标 - 当前事件的 y 轴坐标。
     * @return boolean 返回 true 表示消费该事件。
     */
    boolean onScroll(MotionEvent e1, MotionEvent e2, float distanceX, float distanceY);

    /**
     * 长按（按下 500ms 不松手）被调用。
     */
    void onLongPress(MotionEvent e);

    /**
     * 快速滑动时手指抬起后调用 (惯性滑动)。
     * 返回 true 表示消费该事件。
     * 
     * @param e1 :按下时的 ACTION_DOWM 事件。
     * @param e2 :手指抬起时的 Event。
     * @param velocityX :在 X 轴上的运动速度 (像素／秒)。。
     * @param velocityY :在 Y 轴上的运动速度 (像素／秒)。
     * @return boolean 返回 true 表示消费该事件。
     */
    boolean onFling(MotionEvent e1, MotionEvent e2, float velocityX, float velocityY);
}

```

### 4.1.2 OnDoubleTapListener

```java
public interface OnDoubleTapListener {

    /**
     * 单击时被调用。
     * 在单击事件发生后 300ms 且没有后续特殊事件（双击）触发。
     */
    boolean onSingleTapConfirmed(MotionEvent e);

   /**
     * 双击行为中，第二次双击按下时调用。
     * 先于 onDoubleTapEvent() 调用。
     */
    boolean onDoubleTap(MotionEvent e);

   /**
     * 双击第二次按下、第二次按下后移动、第二次按下后抬起时都会调用。
     * 用法：长按拖拽等。
     */
    boolean onDoubleTapEvent(MotionEvent e);
}
```

### 4.1.3 GestureDetector 常用方法

- setIsLongpressEnabled - 通过布尔值设置是否允许触发长按事件，true 表示允许，false 表示不允许。可用于解决长按屏幕后无法拖动的现象。
- isLongpressEnabled - 判断当前是否允许触发长按事件，true 表示允许，false 表示不允许。
 
## 4.2 ScaleGestureDetector 缩放手势

ScaleGestureDetector 有两个监听器：OnScaleGestureListener 和 SimpleOnScaleGestureListener，SimpleOnScaleGestureListener 为 OnScaleGestureListener 的空实现。

```java
public interface OnScaleGestureListener {
    
    /**
     * 缩放被触发 (会调用 0 次或者多次)。
     * 如果返回 true 则表示当前缩放事件已经被处理，检测器会重新积累缩放因子，返回 false 则会继续积累缩放因子。
     */
    public boolean onScale(ScaleGestureDetector detector);

   /**
     * 缩放手势开始，当两个手指放在屏幕上的时候会调用该方法 (只调用一次)。
     * 如果返回 false 则表示不使用当前这次缩放手势。
     */
    public boolean onScaleBegin(ScaleGestureDetector detector);

   /**
     * 缩放手势结束。
     */
    public void onScaleEnd(ScaleGestureDetector detector);
}
```

### 4.2.1 ScaleGestureDetector 常用方法

- getFocusX() - 缩放中心 X 坐标。
- getFocusY() - 缩放中心 Y 坐标。
- getScaleFactor() - 缩放因子。

## 4.3 VelocityTracker 速度跟踪器

在 GestureDetector 的适用范围外，还可以适用 VelocityTracker 用来计算手指移动速度。VelocityTracker 的使用场景：用于开发者决定在什么时刻才去计算一定时间内的平均滑动速度。

使用方式如下：

1. 在 ACTION_DOWM 事件中，通过 velocityTracker.obtain() 拿到一个实例（在使用完后释放）；或在初始化的时候实例化，在调用的时候 velocityTracker.clear() 进行重置。
2. 在 onTouchEvent() 中调用 velocityTracker.addMovement(event) 添加每一个事件。
3. 在需要手指移动速度的地方调用 velocityTracker.computeCurrentVelocity(units, maxVelocity) 计算实时速度，并通过 getXVelocity()/getYVelocity() 拿到计算后的速度。
    1. units 表示每 units 毫秒手指移动的像素值。
    2. maxVelocity 为所获取到的速度上限。

例题：https://github.com/rengwuxian/HenCoderPlus/blob/master/14_view_pager/src/main/java/com/hencoder/a14_view_pager/view/TwoPager.java

# 五、滑动 Scroll

## 5.1 scrollTo()/scrollBy()

scrollTo()/scrollBy() 多用于滑动控件对绘制的内容设置偏移。方法参数 scroll 填正值时，绘制内容会负向移动。

scrollTo()/scrollBy() 是瞬时方法，且方法只是改变了一些变量属性。如果要变成动画效果，可以配合 View.computeScroll() 使用，该方法会在重绘（invaladata()）时自动调用。

## 5.2 OverScroller

OverScroller 用于帮助开发者计算每帧滑动的距离。 

### 5.2.1 OverScroller.startScroll()

该方法常用于用户松开手指后的收尾 UI，例如 ViewPager 滑动到另一页的一半时抬起手，需将 UI 自动滑动到具体某一页。再或者下拉刷新松手后，UI 自动滑动到偏移量为 0 的时候。

```java
public boolean onTouchEvent(MotionEvent event) {
    overScroller.startScroll(startX, startY, dx, dy);
    // 一帧后调用 Invalidate。
    postInvalidateOnAnimation();
}

// onDraw() 前调用。
public void computeScroll() {
    if(overScroller.computeScrollOffst()){
        scrollTo(overScroller.getCurrX(), overScroller.getCurrY())
        postInvalidateOnAnimation();
    }
}
```

### 5.2.2 OverScroller.fling()

该方法常用于 OnGestureListener.onFling() 中来启动惯性滑动的计算：

```java
public boolean onFling(MotionEvent e1,MotionEvent e2,float velocityX, float velocityY){
    // 初始化惯性滑动。
    scroller.fling(startX, startY, velocityX, velocityY, minX, maxX, minY, maxY);
    // 延迟 1 帧调用。
    postAnimation(this);
}

@Override
public void run(){
    // 滑动结束后停止该 Runnable。
    if(scroller.computeScrollOffset()){
        offsetX = scroller.getCurrX();
        offsetY = scroller.getCurrY();
        
        invaladata();
        // 获取 1 帧后的位置。
        postAnimation(this);
    }
}

```

# 六、拖拽 Drag

## 6.1 OnDragListener

使用 OnDragListener 不需要自定义 View，调用 startDrag()/startDragAndDrop() 便可开启拖拽，同时会回调到 OnDragListener。

该拖拽的本质是在手指触摸的 View 生成一个影子图像（像素）。一般用于将“数据”拖拽到其它地方。

```java
/**
 * 试图拖拽子 View 时调用。
 * 
 * @param data 用于传递给拖拽目标视图的数据（支持跨进程、跨应用），比较“重”。
 * @param shadowBuilder 构建拖拽时的影子图像样式。
 * @param myLocalState 在同一 Activity 中向视图分配拖动事件时，可以通过使用此对象传递数据，不会传递到其它活动或进程，比较“轻”。
 *
 * @return true 表示可以拖动，false 反之
 */
public final boolean startDragAndDrop(ClipData data, DragShadowBuilder shadowBuilder, Object myLocalState, int flags)
```
事件类型:

- DagEvent.ACTION_DRAG_STARTED - 拖拽事件开始（所有同级 View 都会触发）。
- DagEvent.ACTION_DRAG_LOCATION - 当拖动影子图像还在视图的边界框范围中触发，可以拿到在目标视图中的位置。
- DagEvent.ACTION_DROP - ACTION_DRAG_STARTED 返回 true 的同级所有子视图释放影子图像时触发。
- DagEvent.ACTION_DRAG_ENDED - 用户松手拖拽事件结束触发（所有 同级 View）。
- DagEvent.ACTION_DRAG_ENTERED - 拖拽影子图像进入某个目标视图时，目标视图会触发该回调。ACTION_DRAG_STARTED 事件中返回 true 的子 View 才能触发。
- DagEvent.ACTION_DRAG_EXITED - 拖拽影子图像移出了目标视图边界。

## 6.2 ViewDragHelper

ViewDragHelper 用于拖动 ViewGroup 中的某个子 View。它拖拽的本质是改变子 View 中实际的坐标。适用场景：DrawerLayout 那样的 UI 效果。

使用方式：

```java
ViewDragHelper dragHelper = ViewDragHelper.create(parent,callback)

public boolean onInterceptTouchEvent(MotionEvent ev) {
    return dragHelper.shouldInterceptTouchEvent(ev)
}

public boolean onTouchEvent(MotionEvent event){
    dragHelper.processTouchEvent(event);
    return true;
}

@Override
public void computeScroll() {
    // 调用 dragHelper.settleCapturedViewAt() 触发计算后会 continueSettling() 会返回 true。
    if (dragHelper.continueSettling(true)) {
        ViewCompat.postInvalidateOnAnimation(this);
    }
}

```

callback 中的回调方法：

```java
public abstract static class Callback {
    /**
     * 试图拖拽子 View 时调用。
     *
     * @return true 表示可以拖动，false 则反之。
     */
    public abstract boolean tryCaptureView(@NonNull View child, int pointerId);

    /**
     * 控制水平拖拽范围。
     * 
     * @param left 默认的算法所计算出的用户想拖动到的水平坐标。
     * @return 在 父 View 的 x 轴坐标。
     */
    public int clampViewPositionHorizontal(@NonNull View child, int left, int dx) {
        return left;
    }

    /**
     * 控制垂直拖拽范围。
     * 
     * @param top 默认的算法所计算出的用户想拖动到的垂直坐标。
     * @return 在 父 View 的 y 轴坐标。
     */
    public int clampViewPositionVertical(@NonNull View child, int top, int dy) {
        return top;
    }

    /**
     * 拖拽状态变化（例如由拖拽状态变为正常状态）。
     */
    public void onViewDragStateChanged(int state) {
    }

    /**
     * 子 View 的位置发生变化。
     */
    public void onViewPositionChanged(@NonNull View changedView, int left, int top, @Px int dx, @Px int dy) {
    }

    /**
     * 子 View 被确定接受拖拽时调用，一般用于做初始化操作，例如记录 View 开始拖拽前的坐标。
     */
    public void onViewCaptured(@NonNull View capturedChild, int activePointerId) {
        // capturedChild.setElevation(getElevation() + 1);
        // capturedLeft = capturedChild.getLeft();
        // capturedTop = capturedChild.getTop();
    }

    /**
     * 松开手指时（拖拽结束）。
     * 
     * @param xvel x 轴方向滑动速度。
     * @param yvel y 轴方向滑动速度。
     */
    public void onViewReleased(@NonNull View releasedChild, float xvel, float yvel) {
        // 将被拖拽的 View 设置到坐标 (x,y)，和滑动的过程一样，这是一个持续的过程，
        // 需要不断的计算当前帧的坐标（配合 dragHelper.continueSettling(true)）后刷新界面。
        // dragHelper.settleCapturedViewAt(x, y);
        // postInalidateOnAnimation();
    }
```