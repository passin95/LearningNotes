
# 触摸反馈

<!-- TOC -->

- [触摸反馈](#触摸反馈)
- [一、MotionEvent](#一motionevent)
    - [1.1 单点触控](#11-单点触控)
    - [1.2 多点触控](#12-多点触控)
- [二、事件分发机制](#二事件分发机制)
    - [2.1 View 的事件分发机制](#21-view-的事件分发机制)
        - [2.1.1 View.dispatchTouchEvent()](#211-viewdispatchtouchevent)
        - [2.1.2 View.onTouchEvent()](#212-viewontouchevent)
            - [2.1.2.1 View.checkForLongClick()](#2121-viewcheckforlongclick)
    - [2.2 ViewGroup 的 dispatchTouchEvent()](#22-viewgroup-的-dispatchtouchevent)
- [三、触摸反馈算法](#三触摸反馈算法)
- [四、手势检测 GestureDetector](#四手势检测-gesturedetector)
    - [4.1 GestureDetector](#41-gesturedetector)
        - [4.1.1 OnGestureListener](#411-ongesturelistener)
        - [4.1.2 OnDoubleTapListener](#412-ondoubletaplistener)
        - [4.1.3 GestureDetector 常用方法](#413-gesturedetector-常用方法)
    - [4.2 ScaleGestureDetector 缩放手势](#42-scalegesturedetector-缩放手势)
        - [4.2.1 ScaleGestureDecetor 常用方法](#421-scalegesturedecetor-常用方法)
    - [4.3 VelocityTracker 速度跟踪器](#43-velocitytracker-速度跟踪器)
- [五、滑动 Scroll](#五滑动-scroll)
    - [5.2 OverScroller](#52-overscroller)
        - [5.2.1 OverScroller.fling()](#521-overscrollerfling)
        - [5.2.2 scrollTo()/scrollBy()](#522-scrolltoscrollby)
- [六、拖拽 Drag](#六拖拽-drag)
    - [6.1 OnDragListener](#61-ondraglistener)
    - [6.2 ViewDragHelper](#62-viewdraghelper)

<!-- /TOC -->

# 一、MotionEvent

## 1.1 单点触控

事件类型：

- ACTION_DOWN： 手指 **初次接触到屏幕时** 触发。
- ACTION_MOVE：手指在 **屏幕上滑动** 时触发，会多次触发。
- ACTION_UP：手指 **离开屏幕** 时触发。
- ACTION_CANCEL：事件 **被上层拦截** 时触发
- ACTION_OUTSIDE：手指 **不在控件区域** 时触发（例如 Dialog）。

方法：

- getAction()：获取事件类型。
- getX()：获得触摸点在当前 View 的 X 轴坐标。
- getY()：获得触摸点在当前 View 的 Y 轴坐标。
- getRawX()：获得触摸点在整个屏幕的 X 轴坐标。
- getRawY()：获得触摸点在整个屏幕的 Y 轴坐标。

## 1.2 多点触控

事件类型：

- ACTION_DOWN： **第一个** 手指 **接触到屏幕时** 触发。
- ACTION_MOVE：手指在 **屏幕上滑动** 时触发，会多次触发。
- ACTION_UP：**最后一个** 手指 **离开屏幕** 时触发。
- ACTION_POINTER_DOWN：有非主要的手指按下 (**即按下之前已经有手指在屏幕上**)。
- ACTION_POINTER_UP：有非主要的手指抬起 (即抬起之后仍然有手指在屏幕上)。

方法：

- getActionMasked()：与 getAction() 类似，多点触控必须使用这个方法获取事件类型。
- getActionIndex()：获取该事件是哪个指针 (手指) 产生的。
- getPointerCount()：获取在屏幕上手指的个数。
- getPointerId(int pointerIndex)：获取一个指针 (手指) 的唯一标识符 ID，在手指按下和抬起之间 ID 始终不变。
- findPointerIndex(int pointerId)：通过 PointerId 获取到当前状态下 PointIndex，之后通过 PointIndex 获取其他内容。
- getX(int pointerIndex)：获取某一个指针 (手指) 的 X 坐标
- getY(int pointerIndex)：获取某一个指针 (手指) 的 Y 坐标

多点触控将 index 属性和事件类型合并以一个 int 作为标识，用低 8 位 (0x000000ff) 表示事件类型，再往前的 8 位 (0x0000ff00) 表示事件编号。

追踪事件流，请认准 PointId，ActionIndex 只有在手指按下 (down) 和抬起 (up) 时是有用的。

PointId 在手指按下时产生，手指抬起或者事件被取消后消失，可以在手指按下或抬起时，通过 getPointerId(int pointerIndex) 获得，pointerIndex 也就是 ActionIndex。

# 二、事件分发机制

事件分发机制的大体流程：

1. ViewGroup 会从 Activity 开始到根布局再不断向子 View（ViewGroup） 询问是否接管事件流。
2. onTouchEvent() 和 onInterceptTouchEvent() 都是在 dispatchTouchEvent() 中调用，一个事件分发的过程本质上是从根 View 递归调用 dispatchTouchEvent() 的过程。
3. 最终根据 View 或 ViewGroup 的 dispatchTouchEvent() 方法的返回值取决于是否消费该事件。

事件分发的源码分析基于 Android SDK 28。

## 2.1 View 的事件分发机制

### 2.1.1 View.dispatchTouchEvent()

当 View 的 dispatchTouchEvent() 返回 false 时，表示不消费该事件流。

以下代码非所有源代码，只保留了主干源码。

```java
public boolean dispatchTouchEvent(MotionEvent event) {

    // 标记是否消费事件。
    boolean result = false;

    if (onFilterTouchEventForSecurity(event)) {
        // 如果该 View 处于可用，并且滑动了滚动条。
        if ((mViewFlags & ENABLED_MASK) == ENABLED && handleScrollBarDragging(event)) {
            result = true;
        }
        // 是否设置了 OnTouchListener，如果设置了调用 mOnTouchListener.onTouch(this, event),
        // 该方法可以选择返回 false，不消费事件。
        ListenerInfo li = mListenerInfo;
        if (li != null && li.mOnTouchListener != null
                && (mViewFlags & ENABLED_MASK) == ENABLED
                && li.mOnTouchListener.onTouch(this, event)) {
            result = true;
        }

        // 如果事件没被消费，调用 View 的 onTouchEvent(event)。
        if (!result && onTouchEvent(event)) {
            result = true;
        }
    }

    return result;
}
```

### 2.1.2 View.onTouchEvent()

```java
public boolean onTouchEvent(MotionEvent event) {
    final float x = event.getX();
    final float y = event.getY();
    final int viewFlags = mViewFlags;
    final int action = event.getAction();

    // 当前 View 是否可点击。
    // 判断标准为只要 CLICKABLE、LONG_CLICKABLE、CONTEXT_CLICKABLE（鼠标等）有一个被标记成 true。
    final boolean clickable = ((viewFlags & CLICKABLE) == CLICKABLE
            || (viewFlags & LONG_CLICKABLE) == LONG_CLICKABLE)
            || (viewFlags & CONTEXT_CLICKABLE) == CONTEXT_CLICKABLE;

    // 如果 View 被标记为不可用。
    if ((viewFlags & ENABLED_MASK) == DISABLED) {
        // View 不可用却 clickable 又为 true 时，直接消费事件，不再向下层 View 传递。
        return clickable;
    }

    // 设置代理 View，将当前 View 的部分区域的事件处理按照代理 View 的逻辑（onTouchEvent()）去执行。
    if (mTouchDelegate != null) {
        if (mTouchDelegate.onTouchEvent(event)) {
            return true;
        }
    }

    // 如果可点击或使用了 TOOLTIP（长按当前 View 时会在长按的坐标上面提示一段信息，xml 的 API 为 tooltipText）。
    // 只要走进该方法，返回值都为 true，也就是说 clickable 为 true 或者使用了 TOOLTIP 都代表消费该事件。
    if (clickable || (viewFlags & TOOLTIP) == TOOLTIP) {
        switch (action) {
            case MotionEvent.ACTION_DOWN:
                // 如果该事件通过屏触摸屏幕得到，便标志为手指按下。
                if (event.getSource() == InputDevice.SOURCE_TOUCHSCREEN) {
                    mPrivateFlags3 |= PFLAG3_FINGER_DOWN;
                }
                mHasPerformedLongPress = false;

                // 如果不可点击，还走到了这里，说明使用了 TOOLTIP。
                if (!clickable) {
                    // 看到此，可先跳转到 checkForLongClick() 的代码分析。
                    // 该方法主要处理 OnLongClickListener、 Menu 和 TOOLTIP。 
                    // 此时调用该方法也是为了处理 TOOLTIP。
                    checkForLongClick(0, x, y);
                    break;
                }

                // 是否存在一个父 View 是可滑动的控件。
                boolean isInScrollingContainer = isInScrollingContainer();


                if (isInScrollingContainer) {
                    // 预按下状态，经过 100 毫秒后，才设置按下状态，并监听长按事件。
                    mPrivateFlags |= PFLAG_PREPRESSED;
                    if (mPendingCheckForTap == null) {
                        mPendingCheckForTap = new CheckForTap();
                    }
                    mPendingCheckForTap.x = event.getX();
                    mPendingCheckForTap.y = event.getY();
                    postDelayed(mPendingCheckForTap, ViewConfiguration.getTapTimeout());
                } else {
                    // 如果不是在滑动控件，直接设置按下状态，并监听长按事件。
                    // setPressed() 第一个参数的作用是是否产生按下的 drawable（水波纹）。
                    setPressed(true, x, y);
                    checkForLongClick(0, x, y);
                }
                break;

            case MotionEvent.ACTION_MOVE:
                // 更新 drawable 的位置。
                if (clickable) {
                    drawableHotspotChanged(x, y);
                }

                // pointInView()：移动的坐标是否超出 View 的绘制范围。
                // mTouchSlop：在超出 View 的绘制范围 mTouchSlop 个像素内依旧算移动该 View。
                // 当移除当前 View 的范围后，会取消一系列事件。
                if (!pointInView(x, y, mTouchSlop)) {

                    // 取消预按下事件 Runnable。
                    removeTapCallback();
                    // 取消长按事件 Runnable。
                    removeLongPressCallback();
                    // 取消按下的 drawable 效果。
                    if ((mPrivateFlags & PFLAG_PRESSED) != 0) {
                        setPressed(false);
                    }
                    // 清理 TOOLTIP 标记。
                    mPrivateFlags3 &= ~PFLAG3_FINGER_DOWN;
                }
                break;

            case MotionEvent.ACTION_UP:
                // 清理 TOOLTIP 标记。
                mPrivateFlags3 &= ~PFLAG3_FINGER_DOWN;

                // 如果使用了 TOOLTIP，则对 TOOLTIP 进行相关资源回收（UI 方面表现为 1500ms 后显示的字体消失）。
                if ((viewFlags & TOOLTIP) == TOOLTIP) {
                    handleTooltipUp();
                }
                // 如果不可点击，回收资源，不再往下执行。
                if (!clickable) {
                    // 这里主要移除 TOOLTIP 相关的 Runnable。
                    removeTapCallback();
                    removeLongPressCallback();
                    mInContextButtonPress = false;
                    mHasPerformedLongPress = false;
                    mIgnoreNextUpEvent = false;
                    break;
                }

                // prepressed 为 true 表示用户处于预按下状态，就抬起了手。
                boolean prepressed = (mPrivateFlags & PFLAG_PREPRESSED) != 0;
                if ((mPrivateFlags & PFLAG_PRESSED) != 0 || prepressed) {
                    boolean focusTaken = false;
                    // 如果当前 View 没有获取到焦点。
                    if (isFocusable() && isFocusableInTouchMode() && !isFocused()) {
                        // 尝试获取焦点。
                        focusTaken = requestFocus();
                    }

                    // 设置为按下状态，显示 drawable 效果，让用户知道他曾经按下过。
                    if (prepressed) {
                        setPressed(true, x, y);
                    }

                    // mHasPerformedLongPress 为 true 表示消费了长按事件，则不再响应点击事件。
                    if (!mHasPerformedLongPress && !mIgnoreNextUpEvent) {
                        // 长按事件默认会在 1500 ms 后尝试响应，可能也设置了长按事件和点击事件，
                        // 在 1500 ms 内抬起了手，响应点击事件，并移除长按事件的 Runnable。
                        removeLongPressCallback();

                        // 如果获取到了焦点，则不再响应点击事件。
                        // 例如点击 EditText 的输入框，优先获取焦点后，便不再响应点击事件。
                        if (!focusTaken) {
                            if (mPerformClick == null) {
                                mPerformClick = new PerformClick();
                            }
                            if (!post(mPerformClick)) {
                                performClickInternal();
                            }
                        }
                    }

                    if (mUnsetPressedState == null) {
                        mUnsetPressedState = new UnsetPressedState();
                    }
                    if (prepressed) {
                        // 处于预按下的状态便抬手，便在 64 ms 毫秒后，设置为未按下状态，关闭 drawable 效果。
                        postDelayed(mUnsetPressedState,
                                ViewConfiguration.getPressedStateDuration());
                    } else if (!post(mUnsetPressedState)) {
                        // 否则直接关闭 drawable 效果。
                        mUnsetPressedState.run();
                    }

                    // 移除 TapCallback，当用户设置了长按监听，并不消费长按事件时还使用了 TOOLTIP，
                    // 便可能触发显示 TOOLTIP 的Runnable。
                    removeTapCallback();
                }
                mIgnoreNextUpEvent = false;
                break;

            case MotionEvent.ACTION_CANCEL:
                // Drawable 恢复未按压状态、重置各类标记、移除各类 Runnable。
                if (clickable) {
                    setPressed(false);
                }
                removeTapCallback();
                removeLongPressCallback();
                mInContextButtonPress = false;
                mHasPerformedLongPress = false;
                mIgnoreNextUpEvent = false;
                mPrivateFlags3 &= ~PFLAG3_FINGER_DOWN;
                break;
        }

        return true;
    }

    return false;
}
```

#### 2.1.2.1 View.checkForLongClick()

```java
private void checkForLongClick(int delayOffset, float x, float y) {

    if ((mViewFlags & LONG_CLICKABLE) == LONG_CLICKABLE || (mViewFlags & TOOLTIP) == TOOLTIP) {
        mHasPerformedLongPress = false;

        if (mPendingCheckForLongPress == null) {
            // CheckForLongPress 为一个 Runnable。
            mPendingCheckForLongPress = new CheckForLongPress();
        }
        mPendingCheckForLongPress.setAnchor(x, y);
        mPendingCheckForLongPress.rememberWindowAttachCount();
        mPendingCheckForLongPress.rememberPressedState();
        // 向 Handler 队列中添加一个延迟执行的 Runnable。
        // delayOffset 一般为预按下的所消耗的时间。使长按的总时间保持一致。
        postDelayed(mPendingCheckForLongPress,
                ViewConfiguration.getLongPressTimeout() - delayOffset);
    }
}
```

一路深挖源码直至 performLongClickInternal() 方法。

```java
private boolean performLongClickInternal(float x, float y) {
        sendAccessibilityEvent(AccessibilityEvent.TYPE_VIEW_LONG_CLICKED);

        boolean handled = false;
        final ListenerInfo li = mListenerInfo;
        if (li != null && li.mOnLongClickListener != null) {
            // 执行 View 的长按监听回调。
            // 返回值用于标识该 View 是否已消费该事件流的长按事件。
            handled = li.mOnLongClickListener.onLongClick(View.this);
        }

        // 如果没消费，则显示一个长按的菜单。
        if (!handled) {
            final boolean isAnchored = !Float.isNaN(x) && !Float.isNaN(y);
            handled = isAnchored ? showContextMenu(x, y) : showContextMenu();
        }

        // 如果还没消费，并使用了 TOOLTIP，则显示 TOOLTIP 的内容。
        if ((mViewFlags & TOOLTIP) == TOOLTIP) {
            if (!handled) {
                handled = showLongClickTooltip((int) x, (int) y);
            }
        }
        if (handled) {
            performHapticFeedback(HapticFeedbackConstants.LONG_PRESS);
        }
        return handled;
    }
```


## 2.2 ViewGroup 的 dispatchTouchEvent()

当 ViewGroup 的 dispatchTouchEvent() 返回 false 时，表示它和它的子 View 都不接管事件流。

以下代码非所有源代码，只保留了主干源码。

```java
public boolean dispatchTouchEvent(MotionEvent ev) {
    if (mInputEventConsistencyVerifier != null) {
        mInputEventConsistencyVerifier.onTouchEvent(ev, 1);
    }

    // If the event targets the accessibility focused view and this is it, start
    // normal event dispatch. Maybe a descendant is what will handle the click.
    if (ev.isTargetAccessibilityFocus() && isAccessibilityFocusedViewOrHost()) {
        ev.setTargetAccessibilityFocus(false);
    }

    boolean handled = false;

    // 为了确保触摸事件的安全，防止存在悬浮窗监听触摸事件。
    if (onFilterTouchEventForSecurity(ev)) {
        final int action = ev.getAction();
        final int actionMasked = action & MotionEvent.ACTION_MASK;

        if (actionMasked == MotionEvent.ACTION_DOWN) {
            // 当用户初次按下（因为事件的开始都从 MotionEvent.ACTION_DOWN 开始）,
            // 清空 TouchTargets 以及 FLAG_DISALLOW_INTERCEPT 标记。
            // TouchTarget：每一个子 View 是被哪些 pointer 按下的（以 View 为单位）。
            // FLAG_DISALLOW_INTERCEPT：用于子 View 向父 View 表示不希望父 View 拦截自己的事件。
            cancelAndClearTouchTargets(ev);
            resetTouchState();
        }

        // 是否拦截。
        final boolean intercepted;
        // 如果是按下事件或者已存在一个某一个子 View 被按下（被该子 View 消费），
        // 为 true 时才需要判断是否对事件进行拦截。
        if (actionMasked == MotionEvent.ACTION_DOWN
                || mFirstTouchTarget != null) {
            // disallowIntercept 为 true 时：子 View 向父 View 表示不希望父 View 拦截自己的事件。
            final boolean disallowIntercept = (mGroupFlags & FLAG_DISALLOW_INTERCEPT) != 0;
            if (!disallowIntercept) {
                // 父 View 是否拦截该事件。
                intercepted = onInterceptTouchEvent(ev);
                ev.setAction(action); // restore action in case it was changed
            } else {
                intercepted = false;
            }
        } else {
            // 执行到这里，说明父 View 在 ACTION_DOWN 便进行了拦截；
            // 或者在 ACTION_DOWN 时，该 ViewGroup 没有子 View 或没有子 View 对事件进行消费；
            // 使子 View 永远接触不到该事件流。
            intercepted = true;
        }

      	// 如果事件被该 ViewGroup 拦截或已存在一个子 View 被按下。
        if (intercepted || mFirstTouchTarget != null) {
            // 关闭通过事件进行焦点获取。
            ev.setTargetAccessibilityFocus(false);
        }

        // 检查事件流是否被取消(ACTION_CANCEL)。
        final boolean canceled = resetCancelNextUpFlag(this)
                || actionMasked == MotionEvent.ACTION_CANCEL;

        // Update list of touch targets for pointer down, if needed.
        final boolean split = (mGroupFlags & FLAG_SPLIT_MOTION_EVENTS) != 0;
        TouchTarget newTouchTarget = null;
        boolean alreadyDispatchedToNewTouchTarget = false;

        // 如果没有取消也没有被拦截（进入事件分发）
        if (!canceled && !intercepted) {

            // 如果事件是针对可访问性焦点视图，我们将其提供给具有可访问性焦点的 View。
            // 如果它不处理它，我们清除该标志并像往常一样将事件分派给所有的 ChildView。
            // 我们检测并避免保持这种状态，因为这个情况非常罕见。
            View childWithAccessibilityFocus = ev.isTargetAccessibilityFocus()
                    ? findChildWithAccessibilityFocus() : null;

            // 如果是一个按下事件时，是如何将该事件分配哪个子 View。
            if (actionMasked == MotionEvent.ACTION_DOWN
                    || (split && actionMasked == MotionEvent.ACTION_POINTER_DOWN)
                    || actionMasked == MotionEvent.ACTION_HOVER_MOVE) {
                // 每一次以 ACTION_DOWN 事件开始，actionIndex 都从 0 开始标记。
                final int actionIndex = ev.getActionIndex(); 
                // idBitsToAssign 相当于每一个 MotionEvent 的身份证，作为唯一标识。
                final int idBitsToAssign = split ? 1 << ev.getPointerId(actionIndex)
                        : TouchTarget.ALL_POINTER_IDS;

                // 清除此指针 ID 的早期触摸目标，防止不同步。
                removePointersFromTouchTargets(idBitsToAssign);

                final int childrenCount = mChildrenCount;
                if (newTouchTarget == null && childrenCount != 0) {
                    final float x = ev.getX(actionIndex);
                    final float y = ev.getY(actionIndex);
                    // 写在 xml 布局最后的 View 不一定是最后绘制完成的 View，此处拿到的是以绘制完成作为排序标准的所有子 View。
                    // 从前向后扫描子 View（前为先绘制完成的 View）。
                    final ArrayList<View> preorderedList = buildTouchDispatchChildList();
                    final boolean customOrder = preorderedList == null
                            && isChildrenDrawingOrderEnabled();
                    final View[] children = mChildren;
                    // 从最上面的 View 向被覆盖的 View 遍历。
                    for (int i = childrenCount - 1; i >= 0; i--) {
                        final int childIndex = getAndVerifyPreorderedIndex(
                                childrenCount, i, customOrder);
                        final View child = getAndVerifyPreorderedView(
                                preorderedList, children, childIndex);

                        // 如果有一个视图具有可访问性焦点，我们希望它首先获取事件，
                      	// 如果不处理，我们将执行正常的分派。 
                        // 尽管这可能会分发两次，但它能保证在给定的时间内更安全的执行。
                        if (childWithAccessibilityFocus != null) {
                            if (childWithAccessibilityFocus != child) {
                                continue;
                            }
                            childWithAccessibilityFocus = null;
                            i = childrenCount - 1;
                        }

                        // 以下 2 种情况的子 View 不接受事件：
                        // 1、不可见的时候又没有设置动画。
                        // 2、该子 View 不处于可接受事件的坐标范围内，逻辑如下：
                        // 2.1 会先调用子 View 的 hasIdentityMatrix 方法来判断这个 View 是否应用过位移、缩放、旋转之类的属性动画；
                        // 2.2 如果应用过的话，那接下来还会把触摸点映射到该子 View 的逆矩阵上(getInverseMatrix)，如果没有应用过则直接使用触摸点的坐标；
                        // 2.3 判断处理后的触摸点，是否在该子 View 的边界范围内。
                        if (!canViewReceivePointerEvents(child)
                                || !isTransformedTouchPointInView(x, y, child, null)) {
                            ev.setTargetAccessibilityFocus(false);
                            continue;
                        }

                        newTouchTarget = getTouchTarget(child);
                        // 该子 View 是否在被触摸过（在当前事件流处于某一个事件）。
                        if (newTouchTarget != null) {
                            // 将新的事件添加到该子 View 的 TouchTarget，并跳出。
                            newTouchTarget.pointerIdBits |= idBitsToAssign;
                            break;
                        }

                        resetCancelNextUpFlag(child);
                
                        // 找到合适的子 View 之后，调用子 View 的 dispatchTouchEvent(event)。
                        if (dispatchTransformedTouchEvent(ev, false, child, idBitsToAssign)) {
                            mLastTouchDownTime = ev.getDownTime();
                            if (preorderedList != null) {
                                for (int j = 0; j < childrenCount; j++) {
                                    if (children[childIndex] == mChildren[j]) {
                                        mLastTouchDownIndex = j;
                                        break;
                                    }
                                }
                            } else {
                                mLastTouchDownIndex = childIndex;
                            }
                            mLastTouchDownX = ev.getX();
                            mLastTouchDownY = ev.getY();
                            // 添加一个新的 TouchTarget，并将它赋值给 mFirstTouchTarget，
                            // 表示最近一次触摸的 子 View。
                            newTouchTarget = addTouchTarget(child, idBitsToAssign);
                            alreadyDispatchedToNewTouchTarget = true;
                            break;
                        }

                        // The accessibility focus didn't handle the event, so clear
                        // the flag and do a normal dispatch to all children.
                        ev.setTargetAccessibilityFocus(false);
                    }
                    if (preorderedList != null) preorderedList.clear();
                }

                if (newTouchTarget == null && mFirstTouchTarget != null) {
                    // 如果此时没有任何子 View 接受该事件，
                    // 将该事件自动添加给最近的 TouchTarget。
                    newTouchTarget = mFirstTouchTarget;
                    while (newTouchTarget.next != null) {
                        newTouchTarget = newTouchTarget.next;
                    }
                    newTouchTarget.pointerIdBits |= idBitsToAssign;
                }
            }
        }


        // 分发 TouchTarget。
        if (mFirstTouchTarget == null) {
            // mFirstTouchTarget == null，说明没有子 View 消费过事件流,
            // 则最终调用 super.dispatchTouchEvent(event)，即将 ViewGroup 看做 View。
            handled = dispatchTransformedTouchEvent(ev, canceled, null,
                    TouchTarget.ALL_POINTER_IDS);
        } else {
            // 如果存在某个子 View 消费过该事件流。
            // 发送到触摸目标，如果我们已经发送到目标，则排除新的触摸目标。必要时取消触摸目标
            TouchTarget predecessor = null;
            TouchTarget target = mFirstTouchTarget;
            while (target != null) {
                final TouchTarget next = target.next;
                if (alreadyDispatchedToNewTouchTarget && target == newTouchTarget) { 
                    // 调用到这里说明该次事件为某个子 View 的第一个事件（ACTION_DOWM 或 ACTION_POINTER_DOWN），已在构建该子 View 的 TouchTarget 时便发送到事件到该 View。
                    // 设置 handled 为 true，向父 ViewGroup 表示自己（ViewGroup）消费该事件。
                    handled = true;
                } else {
                    // 调用到这里说明该次事件非 ACTION_DOWM 或 ACTION_POINTER_DOWN。
                    
                    final boolean cancelChild = resetCancelNextUpFlag(target.child)
                            || intercepted;
                    // 如果 cancelChild 为 true，给子 View 发送一个 ACTION_CANCEL，并向父 ViewGroup 表示自己消费该事件。
                    // 如果 cancelChild 为 false，将新的事件发送给目标子 View。
                    if (dispatchTransformedTouchEvent(ev, cancelChild,
                            target.child, target.pointerIdBits)) {
                        handled = true;
                    }
                    // 如果 cancelChild 为 true（例如被自身拦截），释放所有子 View 的 TouchTarget 资源。
                    if (cancelChild) {
                        if (predecessor == null) {
                            mFirstTouchTarget = next;
                        } else {
                            predecessor.next = next;
                        }
                        target.recycle();
                        target = next;
                        continue;
                    }
                }
                // 遍历该 View 的 TouchTarget 链表，更新链表事件结构。
                predecessor = target;
                target = next;
            }
        }

        if (canceled
                || actionMasked == MotionEvent.ACTION_UP
                || actionMasked == MotionEvent.ACTION_HOVER_MOVE) {
            // 如果是 ACTION_CANCEL 或 ACTION_UP 事件（事件结束），重置状态。
            resetTouchState();
        } else if (split && actionMasked == MotionEvent.ACTION_POINTER_UP) {
            // 如果是 ACTION_POINTER_UP 事件（有一个手指抬起），将该 PointerId 从 TouchTarget 移除。
            final int actionIndex = ev.getActionIndex();
            final int idBitsToRemove = 1 << ev.getPointerId(actionIndex);
            removePointersFromTouchTargets(idBitsToRemove);
        }
    }

    if (!handled && mInputEventConsistencyVerifier != null) {
        mInputEventConsistencyVerifier.onUnhandledEvent(ev, 1);
    }
    return handled;
}
```

# 三、触摸反馈算法

手写触摸反馈算法的大体流程：

1. 重写 onTouchEvent()，在里面写上你的触摸反馈算法，并返回 true（是否消费事件取决于 ACTION_DOWN 事件或 ACTION_POINTER_DOWN 时是否返回 true），如果返回 false，则在这组触摸事件流中永不接管当前事件流。
2. 如果是会发生触摸冲突的 ViewGroup，还需要重写 onInterceptTouchEvent()，在事件流开始时返回 false，并在确认接管事件流时返回一次 true，以实现对事件的拦截和接管，并在接管之后对它的子 View 发送一个额外的取消事件 CANCEL。
4. 当子 View 临时需要组织父 View 拦截事件流时，可以调用父 View 的 requestDisallowInterceptTouchEvent() ，通知父 View 在当前事件流中不再尝试通过 onInterceptTouchEvent() 来拦截，该方法会递归通知每一级父 View。

编写触摸反馈算法的注意事项：

1. 对于 ViewGroup 来说，onInterceptTouchEvent() 和 onTouchEvent() 的 ACTION_DOWM 事件的逻辑基本或完全一致。因为 ACTION_DOWM 事件做起到起始记录的作用，而这 2 个方法的调用时机是变化的，会造成 onTouchEvent() 可能不会被调用或程序状态有误。
2. ACITON_MOVE 事件一般用于确认滑动，为了减小用户误触摸操作或确认 ViewGroup 需要的滑动限制，使用 Math.abs(event.getX()-downX)>ViewConfiguration.getXXXSlop() 确认。

# 四、手势检测 GestureDetector 

## 4.1 GestureDetector

GestureDetector 可以根据传入的 MotionEvents 识别各种常用的手势。

GestureDetecotr 主要用的有三种监听器：OnDoubleTapListener、OnGestureListener、SimpleOnGestureListener。

SimpleOnGestureListener 为其它两种监听器的空实现，一般情况下可以直接使用 SimpleOnGestureListener。

### 4.1.1 OnGestureListener

```java
public interface OnGestureListener {

    /**
     * 每次 ACTION_DOWM 事件都会回调，
     * 返回 true 表示消费该事件。
     */
    boolean onDown(MotionEvent e);

    /**
     * 按下 100ms 不松手后被调用。
     */
    void onShowPress(MotionEvent e);

    /**
     * 单击时被调用（长按松手不触发、双击第二次不触发）。
     * 返回 true 表示消费该事件。
     */
    boolean onSingleTapUp(MotionEvent e);

    /**
     * 滑动时调用。
     * 
     * @param e1 :按下时的 ACTION_DOWM 事件。
     * @param e2 :当前事件。
     * @param distanceX :按下时的偏移 x 轴坐标 - 当前事件的 x 轴坐标。
     * @param distanceY :按下时的偏移 y 轴坐标 - 当前事件的 y 轴坐标。
     * @return boolean 返回 true 表示消费该事件。
     */
    boolean onScroll(MotionEvent e1, MotionEvent e2, float distanceX, float distanceY);

    /**
     * 长按（按下 500ms 不松手）被调用。
     */
    void onLongPress(MotionEvent e);

    /**
     * 快速滑动时手指抬起后调用 (惯性滑动)。
     * 返回 true 表示消费该事件。
     * 
     * @param e1 :按下时的 ACTION_DOWM 事件。
     * @param e2 :手指抬起时的 Event。
     * @param velocityX :在 X 轴上的运动速度 (像素／秒)。。
     * @param velocityY :在 Y 轴上的运动速度 (像素／秒)。
     * @return boolean 返回 true 表示消费该事件。
     */
    boolean onFling(MotionEvent e1, MotionEvent e2, float velocityX, float velocityY);
}

```

### 4.1.2 OnDoubleTapListener

```java
public interface OnDoubleTapListener {

    /**
     * 单击时被调用。
     * 在单击事件发生后 300ms 且没有后续特殊事件（双击）触发。
     */
    boolean onSingleTapConfirmed(MotionEvent e);

   /**
     * 双击行为中，第二次双击按下时调用。
     * 先于 onDoubleTapEvent() 调用。
     */
    boolean onDoubleTap(MotionEvent e);

   /**
     * 双击第二次按下、第二次按下后移动、第二次按下后抬起时都会调用。
     * 用法：长按拖拽等。
     */
    boolean onDoubleTapEvent(MotionEvent e);
}
```

### 4.1.3 GestureDetector 常用方法

- setIsLongpressEnabled - 通过布尔值设置是否允许触发长按事件，true 表示允许，false 表示不允许。可用于解决长按屏幕后无法拖动的现象。
- isLongpressEnabled - 判断当前是否允许触发长按事件，true 表示允许，false 表示不允许。
 
## 4.2 ScaleGestureDetector 缩放手势

ScaleGestureDetector 有两个监听器：OnScaleGestureListener 和 SimpleOnScaleGestureListener，SimpleOnScaleGestureListener 为 OnScaleGestureListener 的空实现。

```java
public interface OnScaleGestureListener {
    
    /**
     * 缩放被触发 (会调用 0 次或者多次)。
     * 如果返回 true 则表示当前缩放事件已经被处理，检测器会重新积累缩放因子，返回 false 则会继续积累缩放因子。
     */
    public boolean onScale(ScaleGestureDetector detector);

   /**
     * 缩放手势开始，当两个手指放在屏幕上的时候会调用该方法 (只调用一次)。
     * 如果返回 false 则表示不使用当前这次缩放手势。
     */
    public boolean onScaleBegin(ScaleGestureDetector detector);

   /**
     * 缩放手势结束。
     */
    public void onScaleEnd(ScaleGestureDetector detector);
}
```

### 4.2.1 ScaleGestureDecetor 常用方法

- getFocusX() - 缩放中心 X 坐标。
- getFocusY() - 缩放中心 Y 坐标。
- getScaleFactor() - 缩放因子。

## 4.3 VelocityTracker 速度跟踪器

在 GestureDecetor 的适用范围外，还可以适用 VelocityTracker 用来计算手指移动速度。使用方式如下：

1. 在 ACTION_DOWM 事件中，通过 velocityTracker.obtain() 拿到一个实例（在使用完后释放）；或在初始化的时候实例化，在调用的时候 velocityTracker.clear() 进行重置。
2. 在 onTouchEvent() 中调用 velocityTracker.addMovement(event) 添加每一个事件。
3. 在需要手指移动速度的地方调用 velocityTracker.computeCurrentVelocity(units,maxVelocity) 计算实时速度，并通过 getXVelocity()/getYVelocity() 拿到计算后的速度。units 表示取值为每 units ms滑过的像素数。 
    1. units 为 每 units 毫秒手指移动的像素值。
    2. maxVelocity 为所获取到的速度上限。

# 五、滑动 Scroll

## 5.2 OverScroller

OverScroller 用于帮助开发者计算每帧滑动的距离。

### 5.2.1 OverScroller.fling()

该方法常用于 OnGestureListener.onFling() 中来启动惯性滑动的计算：

```java
public boolean onFling(MotionEvent e1,MotionEvent e2,float velocityX, float velocityY){
    // 初始化惯性滑动。
    scroller.fling(startX,startY,velocityX,velocityY,minX,maxX,minY,maxY)
    // 延迟 1 帧调用。
    postAnimation(this)
}

@Override
public void run(){
    // 滑动结束后停止该 Runnable。
    if(scroller.computeScrollOffset()){
        offsetX = scroller.getCurrX();
        offsetY = scroller.getCurrY();
        
        invaladata();
        // 获取 1 帧后的位置。
        postAnimation(this)
    }
}

```

### 5.2.2 scrollTo()/scrollBy()

scrollTo()/scrollBy() 多用于滑动控件对绘制的内容设置偏移。方法参数 scroll 填正值时，绘制内容会负向移动。

scrollTo()/scrollBy() 是瞬时方法，如果要变成动画效果，需配合 View.computeScroll() 使用，
该方法会在重绘（invaladata）时被自动调用。

```java
public boolean onTouchEvent(MotionEvent event) {
    overScroller.startScroll(startX,startY,dx,dy);
    // 一帧后调用 Invalidate。
    postInvalidateOnAnimation();
}

// onDraw() 前调用。
public void computeScroll() {
    if(overScroller.computeScrollOffst()){
        scrollTo(overScroller.getCurrX(),overScroller.getCurrY())
        postInvalidateOnAnimation();
    }
}
```

# 六、拖拽 Drag

## 6.1 OnDragListener

使用 OnDragListener 不需要自定义 View，调用 startDrag()/startDragAndDrop() 便可开启拖拽，同时会回调到 OnDragListener。

该拖拽的本质是在手指触摸的 View 生成一个影子图像。一般用于将“数据”拖拽到其它地方。

```java
/**
 * 试图拖拽子 View 时调用。
 * 
 * @param data 用于获取 view 的某些数据的方式，例如获取描述或文字。
 * @param shadowBuilder 构建拖拽时的影子图像样式。
 * @param myLocalState 
 *
 * @return true 表示可以拖动，false 反之
 */
public final boolean startDragAndDrop(ClipData data, DragShadowBuilder shadowBuilder,Object myLocalState, int flags)
```
事件类型:

- DagEvent.ACTION_DRAG_STARTED - 拖拽事件开始（所有同级 View 都会触发）。
- DagEvent.ACTION_DRAG_LOCATION - 当拖动影子图像还在视图的边界框范围中触发，可以拿到在目标视图中的位置。
- DagEvent.ACTION_DROP - ACTION_DRAG_STARTED 返回true 的同级所有子视图释放影子图像时触发。
- DagEvent.ACTION_DRAG_ENDED - 用户松手拖拽事件结束触发（所有 同级 View）。
- DagEvent.ACTION_DRAG_ENTERED - 拖拽影子图像进入某个目标视图时，目标视图会触发该回调。ACTION_DRAG_STARTED 事件中返回 true 的子 View 才能触发。
- DagEvent.ACTION_DRAG_EXITED - 拖拽影子图像移出了目标视图边界。

## 6.2 ViewDragHelper

ViewDragHelper 用于拖动 ViewGroup 中的某个子 View。它拖拽的本质是改变子 View 中实际的坐标。

使用方式：

```java
ViewDragHelper dragHelper = ViewDragHelper.create(parent,callback)

public boolean onInterceptTouchEvent(MotionEvent ev) {
    return dragHelper.shouldInterceptTouchEvent(ev)
}

public boolean onTouchEvent(MotionEvent event){
    dragHelper.processTouchEvent(event);
    return true;
}
```

callback 中的回调方法：

```java
public abstract static class Callback {
    /**
     * 试图拖拽子 View 时调用。
     *
     * @return true 表示可以拖动，false 则反之。
     */
    public abstract boolean tryCaptureView(@NonNull View child, int pointerId);

    /**
     * 控制水平拖拽范围。
     * 
     * @param left 默认的算法所计算出的用户想拖动的水平距离。
     * @return 水平拖动距离。
     */
    public int clampViewPositionHorizontal(@NonNull View child, int left, int dx) {
        return left;
    }

    /**
     * 控制垂直拖拽范围。
     * 
     * @param top 默认的算法所计算出的用户想拖动的垂直距离。
     * @return 处置拖动距离。
     */
    public int clampViewPositionVertical(@NonNull View child, int top, int dy) {
        return top;
    }

    /**
     * 拖拽状态变化（例如由拖拽状态变为正常状态）。
     * 
     */
    public void onViewDragStateChanged(int state) {
    }

    /**
     * 子 View 的位置发生变化。
     * 
     */
    public void onViewPositionChanged(@NonNull View changedView, int left, int top, @Px int dx, @Px int dy) {
    }

    /**
     * 松开手指时（拖拽结束）。
     * 
     * @param xvel x 轴方向滑动速度。
     * @param yvel y 轴方向滑动速度。
     */
    public void onViewReleased(@NonNull View releasedChild, float xvel, float yvel) {
        // 将被拖拽的 View 至坐标轴 (x,y)。
        dragHelper.settleCapturedViewAt(x,y);
        postInalidateOnAnimation();
    }
```